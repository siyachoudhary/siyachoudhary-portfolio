{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { getFluidValue } from 'fluids';\nimport { createInterpolator } from './createInterpolator';\nimport { colorToRgba } from './colorToRgba';\nimport * as G from './globals';\n// Problem: https://github.com/animatedjs/animated/pull/102\n// Solution: https://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly/658662\nvar numberRegex = /[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\n// Covers rgb, rgba, hsl, hsla\n// Taken from https://gist.github.com/olmokramer/82ccce673f86db7cda5e\nvar colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\\((-?\\d+%?[,\\s]+){2,3}\\s*[\\d\\.]+%?\\))/gi;\n// Covers color names (transparent, blue, etc.)\nvar colorNamesRegex;\n// rgba requires that the r,g,b are integers.... so we want to round them,\n// but we *dont* want to round the opacity (4th column).\nvar rgbaRegex = /rgba\\(([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+)\\)/gi;\nvar rgbaRound = function (_, p1, p2, p3, p4) {\n  return \"rgba(\" + Math.round(p1) + \", \" + Math.round(p2) + \", \" + Math.round(p3) + \", \" + p4 + \")\";\n};\n/**\n * Supports string shapes by extracting numbers so new values can be computed,\n * and recombines those values into new strings of the same shape.  Supports\n * things like:\n *\n *     \"rgba(123, 42, 99, 0.36)\"           // colors\n *     \"-45deg\"                            // values with units\n *     \"0 2px 2px 0px rgba(0, 0, 0, 0.12)\" // CSS box-shadows\n *     \"rotate(0deg) translate(2px, 3px)\"  // CSS transforms\n */\nexport var createStringInterpolator = function (config) {\n  if (!colorNamesRegex) colorNamesRegex = G.colorNames ? new RegExp(\"(\" + Object.keys(G.colorNames).join('|') + \")\", 'g') : /^\\b$/; // never match\n  // Convert colors to rgba(...)\n  var output = config.output.map(function (value) {\n    return getFluidValue(value).replace(colorRegex, colorToRgba).replace(colorNamesRegex, colorToRgba);\n  });\n  // Convert [\"1px 2px\", \"0px 0px\"] into [[1, 2], [0, 0]]\n  var keyframes = output.map(function (value) {\n    return value.match(numberRegex).map(Number);\n  });\n  // Convert [\"1px 2px\", \"0px 0px\"] into [[1, 0], [2, 0]]\n  var outputRanges = keyframes[0].map(function (_, i) {\n    return keyframes.map(function (values) {\n      if (!(i in values)) {\n        throw Error('The arity of each \"output\" value must be equal');\n      }\n      return values[i];\n    });\n  });\n  // Create an interpolator for each animated number\n  var interpolators = outputRanges.map(function (output) {\n    return createInterpolator(__assign(__assign({}, config), {\n      output: output\n    }));\n  });\n  // Use the first `output` as a template for each call\n  return function (input) {\n    var i = 0;\n    return output[0].replace(numberRegex, function () {\n      return String(interpolators[i++](input));\n    }).replace(rgbaRegex, rgbaRound);\n  };\n};","map":{"version":3,"mappings":";AAAA,SAASA,aAAa,QAAQ,QAAQ;AACtC,SAASC,kBAAkB,QAAQ,sBAAsB;AAEzD,SAASC,WAAW,QAAQ,eAAe;AAC3C,OAAO,KAAKC,CAAC,MAAM,WAAW;AAE9B;AACA;AACA,IAAMC,WAAW,GAAG,mDAAmD;AAEvE;AACA;AACA,IAAMC,UAAU,GAAG,0FAA0F;AAE7G;AACA,IAAIC,eAAuB;AAE3B;AACA;AACA,IAAMC,SAAS,GAAG,8DAA8D;AAChF,IAAMC,SAAS,GAAG,UAACC,CAAM,EAAEC,EAAU,EAAEC,EAAU,EAAEC,EAAU,EAAEC,EAAU;EACvE,iBAAQC,IAAI,CAACC,KAAK,CAACL,EAAE,CAAC,UAAKI,IAAI,CAACC,KAAK,CAACJ,EAAE,CAAC,UAAKG,IAAI,CAACC,KAAK,CAACH,EAAE,CAAC,UAAKC,EAAE,MAAG;AAAtE,CAAsE;AAExE;;;;;;;;;;AAUA,OAAO,IAAMG,wBAAwB,GAAG,UACtCC,MAAkC;EAElC,IAAI,CAACX,eAAe,EAClBA,eAAe,GAAGH,CAAC,CAACe,UAAU,GAC1B,IAAIC,MAAM,CAAC,MAAIC,MAAM,CAACC,IAAI,CAAClB,CAAC,CAACe,UAAU,CAAC,CAACI,IAAI,CAAC,GAAG,CAAC,MAAG,EAAE,GAAG,CAAC,GAC3D,MAAM,EAAC;EAEb;EACA,IAAMC,MAAM,GAAGN,MAAM,CAACM,MAAM,CAACC,GAAG,CAAC,eAAK;IACpC,oBAAa,CAACC,KAAK,CAAC,CACjBC,OAAO,CAACrB,UAAU,EAAEH,WAAW,CAAC,CAChCwB,OAAO,CAACpB,eAAe,EAAEJ,WAAW,CAAC;EAFxC,CAEwC,CACzC;EAED;EACA,IAAMyB,SAAS,GAAGJ,MAAM,CAACC,GAAG,CAAC,eAAK;IAAI,YAAK,CAACI,KAAK,CAACxB,WAAW,CAAE,CAACoB,GAAG,CAACK,MAAM,CAAC;EAArC,CAAqC,CAAC;EAE5E;EACA,IAAMC,YAAY,GAAGH,SAAS,CAAC,CAAC,CAAC,CAACH,GAAG,CAAC,UAACf,CAAC,EAAEsB,CAAC;IACzC,gBAAS,CAACP,GAAG,CAAC,gBAAM;MAClB,IAAI,EAAEO,CAAC,IAAIC,MAAM,CAAC,EAAE;QAClB,MAAMC,KAAK,CAAC,gDAAgD,CAAC;;MAE/D,OAAOD,MAAM,CAACD,CAAC,CAAC;IAClB,CAAC,CAAC;EALF,CAKE,CACH;EAED;EACA,IAAMG,aAAa,GAAGJ,YAAY,CAACN,GAAG,CAAC,gBAAM;IAC3C,yBAAkB,uBAAMP,MAAM;MAAEM,MAAM;IAAA,GAAG;EAAzC,CAAyC,CAC1C;EAED;EACA,OAAO,UAACY,KAAa;IACnB,IAAIJ,CAAC,GAAG,CAAC;IACT,OAAOR,MAAM,CAAC,CAAC,CAAC,CACbG,OAAO,CAACtB,WAAW,EAAE;MAAM,aAAM,CAAC8B,aAAa,CAACH,CAAC,EAAE,CAAC,CAACI,KAAK,CAAC,CAAC;IAAjC,CAAiC,CAAC,CAC7DT,OAAO,CAACnB,SAAS,EAAEC,SAAS,CAAC;EAClC,CAAC;AACH,CAAC","names":["getFluidValue","createInterpolator","colorToRgba","G","numberRegex","colorRegex","colorNamesRegex","rgbaRegex","rgbaRound","_","p1","p2","p3","p4","Math","round","createStringInterpolator","config","colorNames","RegExp","Object","keys","join","output","map","value","replace","keyframes","match","Number","outputRanges","i","values","Error","interpolators","input"],"sources":["/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/src/stringInterpolation.ts"],"sourcesContent":["import { getFluidValue } from 'fluids'\nimport { createInterpolator } from './createInterpolator'\nimport { InterpolatorConfig } from './types'\nimport { colorToRgba } from './colorToRgba'\nimport * as G from './globals'\n\n// Problem: https://github.com/animatedjs/animated/pull/102\n// Solution: https://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly/658662\nconst numberRegex = /[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g\n\n// Covers rgb, rgba, hsl, hsla\n// Taken from https://gist.github.com/olmokramer/82ccce673f86db7cda5e\nconst colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\\((-?\\d+%?[,\\s]+){2,3}\\s*[\\d\\.]+%?\\))/gi\n\n// Covers color names (transparent, blue, etc.)\nlet colorNamesRegex: RegExp\n\n// rgba requires that the r,g,b are integers.... so we want to round them,\n// but we *dont* want to round the opacity (4th column).\nconst rgbaRegex = /rgba\\(([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+)\\)/gi\nconst rgbaRound = (_: any, p1: number, p2: number, p3: number, p4: number) =>\n  `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`\n\n/**\n * Supports string shapes by extracting numbers so new values can be computed,\n * and recombines those values into new strings of the same shape.  Supports\n * things like:\n *\n *     \"rgba(123, 42, 99, 0.36)\"           // colors\n *     \"-45deg\"                            // values with units\n *     \"0 2px 2px 0px rgba(0, 0, 0, 0.12)\" // CSS box-shadows\n *     \"rotate(0deg) translate(2px, 3px)\"  // CSS transforms\n */\nexport const createStringInterpolator = (\n  config: InterpolatorConfig<string>\n) => {\n  if (!colorNamesRegex)\n    colorNamesRegex = G.colorNames\n      ? new RegExp(`(${Object.keys(G.colorNames).join('|')})`, 'g')\n      : /^\\b$/ // never match\n\n  // Convert colors to rgba(...)\n  const output = config.output.map(value =>\n    getFluidValue(value)\n      .replace(colorRegex, colorToRgba)\n      .replace(colorNamesRegex, colorToRgba)\n  )\n\n  // Convert [\"1px 2px\", \"0px 0px\"] into [[1, 2], [0, 0]]\n  const keyframes = output.map(value => value.match(numberRegex)!.map(Number))\n\n  // Convert [\"1px 2px\", \"0px 0px\"] into [[1, 0], [2, 0]]\n  const outputRanges = keyframes[0].map((_, i) =>\n    keyframes.map(values => {\n      if (!(i in values)) {\n        throw Error('The arity of each \"output\" value must be equal')\n      }\n      return values[i]\n    })\n  )\n\n  // Create an interpolator for each animated number\n  const interpolators = outputRanges.map(output =>\n    createInterpolator({ ...config, output })\n  )\n\n  // Use the first `output` as a template for each call\n  return (input: number) => {\n    let i = 0\n    return output[0]\n      .replace(numberRegex, () => String(interpolators[i++](input)))\n      .replace(rgbaRegex, rgbaRound)\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}