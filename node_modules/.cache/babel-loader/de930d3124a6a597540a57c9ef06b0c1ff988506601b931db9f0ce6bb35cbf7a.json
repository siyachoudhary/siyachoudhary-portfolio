{"ast":null,"code":"import * as G from './globals';\nexport var noop = function () {};\nexport var defineHidden = function (obj, key, value) {\n  return Object.defineProperty(obj, key, {\n    value: value,\n    writable: true,\n    configurable: true\n  });\n};\nexport var is = {\n  arr: Array.isArray,\n  obj: function (a) {\n    return !!a && a.constructor.name === 'Object';\n  },\n  fun: function (a) {\n    return typeof a === 'function';\n  },\n  str: function (a) {\n    return typeof a === 'string';\n  },\n  num: function (a) {\n    return typeof a === 'number';\n  },\n  und: function (a) {\n    return a === undefined;\n  }\n};\n/** Compare animatable values */\nexport function isEqual(a, b) {\n  if (is.arr(a)) {\n    if (!is.arr(b) || a.length !== b.length) return false;\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  return a === b;\n}\n// Not all strings can be animated (eg: {display: \"none\"})\nexport var isAnimatedString = function (value) {\n  return is.str(value) && (value[0] == '#' || /\\d/.test(value) || !!(G.colorNames && G.colorNames[value]));\n};\n/** An unsafe object/array/set iterator that allows for better minification */\nexport var each = function (obj, cb, ctx) {\n  if (is.fun(obj.forEach)) {\n    obj.forEach(cb, ctx);\n  } else {\n    Object.keys(obj).forEach(function (key) {\n      return cb.call(ctx, obj[key], key);\n    });\n  }\n};\nexport var toArray = function (a) {\n  return is.und(a) ? [] : is.arr(a) ? a : [a];\n};\nexport function flush(queue, iterator) {\n  if (queue.size) {\n    var items = Array.from(queue);\n    queue.clear();\n    each(items, iterator);\n  }\n}","map":{"version":3,"mappings":"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","names":["G","noop","defineHidden","obj","key","value","defineProperty","writable","configurable","is","arr","Array","isArray","a","constructor","name","fun","str","num","und","undefined","isEqual","b","length","i","isAnimatedString","test","colorNames","each","cb","ctx","forEach","Object","keys","call","toArray","flush","queue","iterator","size","items","from","clear"],"sources":["/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/src/helpers.ts"],"sourcesContent":["import { Lookup, Arrify } from './types.util'\nimport * as G from './globals'\n\nexport const noop = () => {}\n\nexport const defineHidden = (obj: any, key: any, value: any) =>\n  Object.defineProperty(obj, key, { value, writable: true, configurable: true })\n\ninterface IsArray {\n  <T>(a: T): a is T & readonly any[]\n}\n\ntype PlainObject<T> = Exclude<T & Lookup, Function | readonly any[]>\n\nexport const is = {\n  arr: Array.isArray as IsArray,\n  obj: <T extends any>(a: T): a is PlainObject<T> =>\n    !!a && a.constructor.name === 'Object',\n  fun: (a: unknown): a is Function => typeof a === 'function',\n  str: (a: unknown): a is string => typeof a === 'string',\n  num: (a: unknown): a is number => typeof a === 'number',\n  und: (a: unknown): a is undefined => a === undefined,\n}\n\n/** Compare animatable values */\nexport function isEqual(a: any, b: any) {\n  if (is.arr(a)) {\n    if (!is.arr(b) || a.length !== b.length) return false\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false\n    }\n    return true\n  }\n  return a === b\n}\n\n// Not all strings can be animated (eg: {display: \"none\"})\nexport const isAnimatedString = (value: unknown): value is string =>\n  is.str(value) &&\n  (value[0] == '#' ||\n    /\\d/.test(value) ||\n    !!(G.colorNames && G.colorNames[value]))\n\ntype Eachable<Value, Key> = {\n  forEach: (cb: (value: Value, key: Key) => void, ctx?: any) => void\n}\n\ntype InferKey<T extends object> = T extends Eachable<any, infer Key>\n  ? Key\n  : Extract<keyof T, string>\n\ntype InferValue<T extends object> = T extends\n  | Eachable<infer Value, any>\n  | { [key: string]: infer Value }\n  ? Value\n  : never\n\n/** An unsafe object/array/set iterator that allows for better minification */\nexport const each = <T extends object, This>(\n  obj: T & { forEach?: Function },\n  cb: (this: This, value: InferValue<T>, key: InferKey<T>) => void,\n  ctx?: This\n) => {\n  if (is.fun(obj.forEach)) {\n    obj.forEach(cb, ctx)\n  } else {\n    Object.keys(obj).forEach(key =>\n      cb.call(ctx!, (obj as any)[key], key as any)\n    )\n  }\n}\n\nexport const toArray = <T>(a: T): Arrify<Exclude<T, void>> =>\n  is.und(a) ? [] : is.arr(a) ? (a as any) : [a]\n\n/** Copy the `queue`, then iterate it after the `queue` is cleared */\nexport function flush<P, T>(\n  queue: Map<P, T>,\n  iterator: (entry: [P, T]) => void\n): void\nexport function flush<T>(queue: Set<T>, iterator: (value: T) => void): void\nexport function flush(queue: any, iterator: any) {\n  if (queue.size) {\n    const items = Array.from(queue)\n    queue.clear()\n    each(items, iterator)\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}