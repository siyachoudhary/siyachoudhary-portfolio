{"ast":null,"code":"import { useLayoutEffect } from 'react-layout-effect';\nimport { each, is, toArray, isAnimatedString, getFluidConfig, Globals, FluidValue, getFluidValue, flush, isEqual, noop, useForceUpdate, usePrev, useOnce, createInterpolator } from '@react-spring/shared';\nexport { FrameLoop, Globals, createInterpolator } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { createContext, useContext, createElement, useRef, useState, useMemo as useMemo$1, useImperativeHandle, Fragment } from 'react';\nimport { getAnimated, AnimatedValue, getPayload, setAnimated, AnimatedArray, AnimatedString } from '@react-spring/animated';\nimport { createStringInterpolator, batchedUpdates, to as to$1, frameLoop, skipAnimation } from '@react-spring/shared/globals';\nimport { useMemoOne, useCallbackOne } from 'use-memo-one';\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport { createStringInterpolator as createStringInterpolator$1 } from '@react-spring/shared/stringInterpolation';\nexport * from '@react-spring/shared/types';\n\n/** API\n *  useChain(references, timeSteps, timeFrame)\n */\n\nfunction useChain(refs, timeSteps) {\n  let timeFrame = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n  useLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      each(refs, (ref, i) => {\n        if (!ref.current) return;\n        const {\n          controllers\n        } = ref.current;\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.\n\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          each(controllers, ctrl => {\n            each(ctrl.queue, props => {\n              props.delay = delay + (props.delay || 0);\n            });\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      each(refs, ref => {\n        const {\n          controllers,\n          start\n        } = ref.current || {};\n        if (controllers && controllers.length) {\n          // Take the queue of each controller\n          const updates = controllers.map(ctrl => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          }); // Apply the queue when the previous ref stops animating\n\n          p = p.then(() => {\n            each(controllers, (ctrl, i) => ctrl.queue.push(...updates[i]));\n            return start();\n          });\n        }\n      });\n    }\n  });\n}\n\n// The `mass` prop defaults to 1\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\nconst linear = t => t;\nconst defaults = _extends(_extends({}, config.default), {}, {\n  mass: 1,\n  damping: 1,\n  easing: linear,\n  clamp: false\n});\nclass AnimationConfig {\n  /**\n   * With higher tension, the spring will resist bouncing and try harder to stop at its end value.\n   *\n   * When tension is zero, no animation occurs.\n   */\n\n  /**\n   * The damping ratio coefficient, or just the damping ratio when `speed` is defined.\n   *\n   * When `speed` is defined, this value should be between 0 and 1.\n   *\n   * Higher friction means the spring will slow down faster.\n   */\n\n  /**\n   * The natural frequency (in seconds), which dictates the number of bounces\n   * per second when no damping exists.\n   *\n   * When defined, `tension` is derived from this, and `friction` is derived\n   * from `tension` and `damping`.\n   */\n\n  /**\n   * The damping ratio, which dictates how the spring slows down.\n   *\n   * Set to `0` to never slow down. Set to `1` to slow down without bouncing.\n   * Between `0` and `1` is for you to explore.\n   *\n   * Only works when `frequency` is defined.\n   *\n   * Defaults to 1\n   */\n\n  /**\n   * Higher mass means more friction is required to slow down.\n   *\n   * Defaults to 1, which works fine most of the time.\n   */\n\n  /**\n   * The initial velocity of one or more values.\n   */\n\n  /**\n   * The smallest velocity before the animation is considered \"not moving\".\n   *\n   * When undefined, `precision` is used instead.\n   */\n\n  /**\n   * The smallest distance from a value before that distance is essentially zero.\n   *\n   * This helps in deciding when a spring is \"at rest\". The spring must be within\n   * this distance from its final value, and its velocity must be lower than this\n   * value too (unless `restVelocity` is defined).\n   */\n\n  /**\n   * For `duration` animations only. Note: The `duration` is not affected\n   * by this property.\n   *\n   * Defaults to `0`, which means \"start from the beginning\".\n   *\n   * Setting to `1+` makes an immediate animation.\n   *\n   * Setting to `0.5` means \"start from the middle of the easing function\".\n   *\n   * Any number `>= 0` and `<= 1` makes sense here.\n   */\n\n  /**\n   * Animation length in number of milliseconds.\n   */\n\n  /**\n   * The animation curve. Only used when `duration` is defined.\n   *\n   * Defaults to quadratic ease-in-out.\n   */\n\n  /**\n   * Avoid overshooting by ending abruptly at the goal value.\n   */\n\n  /**\n   * When above zero, the spring will bounce instead of overshooting when\n   * exceeding its goal value. Its velocity is multiplied by `-1 + bounce`\n   * whenever its current value equals or exceeds its goal. For example,\n   * setting `bounce` to `0.5` chops the velocity in half on each bounce,\n   * in addition to any friction.\n   */\n\n  /**\n   * \"Decay animations\" decelerate without an explicit goal value.\n   * Useful for scrolling animations.\n   *\n   * Use `true` for the default exponential decay factor (`0.998`).\n   *\n   * When a `number` between `0` and `1` is given, a lower number makes the\n   * animation slow down faster. And setting to `1` would make an unending\n   * animation.\n   */\n\n  /**\n   * While animating, round to the nearest multiple of this number.\n   * The `from` and `to` values are never rounded, as well as any value\n   * passed to the `set` method of an animated value.\n   */\n  constructor() {\n    this.tension = void 0;\n    this.friction = void 0;\n    this.frequency = void 0;\n    this.damping = void 0;\n    this.mass = void 0;\n    this.velocity = 0;\n    this.restVelocity = void 0;\n    this.precision = void 0;\n    this.progress = void 0;\n    this.duration = void 0;\n    this.easing = void 0;\n    this.clamp = void 0;\n    this.bounce = void 0;\n    this.decay = void 0;\n    this.round = void 0;\n    Object.assign(this, defaults);\n  }\n}\nfunction mergeConfig(config, newConfig, defaultConfig) {\n  if (defaultConfig) {\n    defaultConfig = _extends({}, defaultConfig);\n    sanitizeConfig(defaultConfig, newConfig);\n    newConfig = _extends(_extends({}, defaultConfig), newConfig);\n  }\n  sanitizeConfig(config, newConfig);\n  Object.assign(config, newConfig);\n  for (const key in defaults) {\n    if (config[key] == null) {\n      config[key] = defaults[key];\n    }\n  }\n  let {\n    mass,\n    frequency,\n    damping\n  } = config;\n  if (!is.und(frequency)) {\n    if (frequency < 0.01) frequency = 0.01;\n    if (damping < 0) damping = 0;\n    config.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;\n    config.friction = 4 * Math.PI * damping * mass / frequency;\n  }\n  return config;\n} // Prevent a config from accidentally overriding new props.\n// This depends on which \"config\" props take precedence when defined.\n\nfunction sanitizeConfig(config, props) {\n  if (!is.und(props.decay)) {\n    config.duration = undefined;\n  } else {\n    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);\n    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {\n      config.duration = undefined;\n      config.decay = undefined;\n    }\n    if (isTensionConfig) {\n      config.frequency = undefined;\n    }\n  }\n}\nconst emptyArray = [];\n/** @internal */\n\n/** An animation being executed by the frameloop */\nclass Animation {\n  constructor() {\n    this.changed = false;\n    this.values = emptyArray;\n    this.toValues = null;\n    this.fromValues = emptyArray;\n    this.to = void 0;\n    this.from = void 0;\n    this.config = new AnimationConfig();\n    this.immediate = false;\n    this.onStart = void 0;\n    this.onChange = void 0;\n    this.onRest = [];\n  }\n}\n\n// @see https://github.com/alexreardon/use-memo-one/pull/10\nconst useMemo = (create, deps) => useMemoOne(create, deps || [{}]);\nfunction callProp(value) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  return is.fun(value) ? value(...args) : value;\n}\n/** Try to coerce the given value into a boolean using the given key */\n\nconst matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));\nconst getProps = (props, i, arg) => props && (is.fun(props) ? props(i, arg) : is.arr(props) ? props[i] : _extends({}, props));\n/** Returns `true` if the given prop is having its default value set. */\n\nconst hasDefaultProp = (props, key) => !is.und(getDefaultProp(props, key));\n/** Get the default value being set for the given `key` */\n\nconst getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : undefined;\n/**\n * Extract the default props from an update.\n *\n * When the `default` prop is falsy, this function still behaves as if\n * `default: true` was used. The `default` prop is always respected when\n * truthy.\n */\n\nconst getDefaultProps = function (props) {\n  let omitKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let defaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let keys = DEFAULT_PROPS;\n  if (props.default && props.default !== true) {\n    props = props.default;\n    keys = Object.keys(props);\n  }\n  for (const key of keys) {\n    const value = props[key];\n    if (!is.und(value) && !omitKeys.includes(key)) {\n      defaults[key] = value;\n    }\n  }\n  return defaults;\n};\n/** Merge the default props of an update into a props cache. */\n\nconst mergeDefaultProps = (defaults, props, omitKeys) => getDefaultProps(props, omitKeys, defaults);\n/** These props can have default values */\n\nconst DEFAULT_PROPS = ['pause', 'cancel', 'config', 'immediate', 'onDelayEnd', 'onProps', 'onStart', 'onChange', 'onRest'];\nconst RESERVED_PROPS = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  onDelayEnd: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onRest: 1,\n  // Transition props\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n  // Internal props\n  keys: 1,\n  callId: 1,\n  parentId: 1\n};\n/**\n * Extract any properties whose keys are *not* reserved for customizing your\n * animations. All hooks use this function, which means `useTransition` props\n * are reserved for `useSpring` calls, etc.\n */\n\nfunction getForwardProps(props) {\n  const forward = {};\n  let count = 0;\n  each(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n      count++;\n    }\n  });\n  if (count) {\n    return forward;\n  }\n}\n/**\n * Clone the given `props` and move all non-reserved props\n * into the `to` prop.\n */\n\nfunction inferTo(props) {\n  const to = getForwardProps(props);\n  if (to) {\n    const out = {\n      to\n    };\n    each(props, (val, key) => key in to || (out[key] = val));\n    return out;\n  }\n  return _extends({}, props);\n} // Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\n\nfunction computeGoal(value) {\n  const config = getFluidConfig(value);\n  return config ? computeGoal(config.get()) : is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\n\n/**\n * This function sets a timeout if both the `delay` prop exists and\n * the `cancel` prop is not `true`.\n *\n * The `actions.start` function must handle the `cancel` prop itself,\n * but the `pause` prop is taken care of.\n */\nfunction scheduleProps(callId, _ref2) {\n  let {\n    key,\n    props,\n    state,\n    actions\n  } = _ref2;\n  return new Promise((resolve, reject) => {\n    let delay;\n    let timeout;\n    let pause = false;\n    let cancel = matchProp(props.cancel, key);\n    if (cancel) {\n      onStart();\n    } else {\n      delay = callProp(props.delay || 0, key);\n      pause = matchProp(props.pause, key);\n      if (pause) {\n        state.resumeQueue.add(onResume);\n        actions.pause();\n      } else {\n        actions.resume();\n        onResume();\n      }\n    }\n    function onPause() {\n      state.resumeQueue.add(onResume);\n      timeout.cancel(); // Cache the remaining delay.\n\n      delay = timeout.time - Globals.now();\n    }\n    function onResume() {\n      if (delay > 0) {\n        state.pauseQueue.add(onPause);\n        timeout = Globals.frameLoop.setTimeout(onStart, delay);\n      } else {\n        onStart();\n      }\n    }\n    function onStart() {\n      state.pauseQueue.delete(onPause); // Maybe cancelled during its delay.\n\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true;\n      }\n      try {\n        actions.start(_extends(_extends({}, props), {}, {\n          callId,\n          delay,\n          cancel,\n          pause\n        }), resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n\n/** @internal */\n\n/** The object given to the `onRest` prop and `start` promise. */\n\n/** The promised result of an animation. */\n\n/** @internal */\nconst getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some(result => result.cancelled) ? getCancelledResult(target) : results.every(result => result.noop) ? getNoopResult(target) : getFinishedResult(target, results.every(result => result.finished));\n/** No-op results are for updates that never start an animation. */\n\nconst getNoopResult = function (target) {\n  let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : target.get();\n  return {\n    value,\n    noop: true,\n    finished: true,\n    target\n  };\n};\nconst getFinishedResult = function (target, finished) {\n  let value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : target.get();\n  return {\n    value,\n    finished,\n    target\n  };\n};\nconst getCancelledResult = function (target) {\n  let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : target.get();\n  return {\n    value,\n    cancelled: true,\n    target\n  };\n};\n\n/**\n * Start an async chain or an async script.\n *\n * Always call `runAsync` in the action callback of a `scheduleProps` call.\n *\n * The `T` parameter can be a set of animated values (as an object type)\n * or a primitive type for a single animated value.\n */\nasync function runAsync(to, props, state, target) {\n  if (props.pause) {\n    await new Promise(resume => {\n      state.resumeQueue.add(resume);\n    });\n  }\n  const {\n    callId,\n    parentId,\n    onRest\n  } = props;\n  const {\n    asyncTo: prevTo,\n    promise: prevPromise\n  } = state;\n  if (!parentId && to === prevTo && !props.reset) {\n    return prevPromise;\n  }\n  return state.promise = (async () => {\n    state.asyncId = callId;\n    state.asyncTo = to; // The default props of any `animate` calls.\n\n    const defaultProps = getDefaultProps(props, [\n    // The `onRest` prop is only called when the `runAsync` promise is resolved.\n    'onRest']);\n    let preventBail;\n    let bail; // This promise is rejected when the animation is interrupted.\n\n    const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject)); // Stop animating when an error is caught.\n\n    const withBailHandler = fn => function () {\n      const onError = err => {\n        if (err instanceof BailSignal) {\n          bail(err); // Stop animating.\n        }\n\n        throw err;\n      };\n      try {\n        return fn(...arguments).catch(onError);\n      } catch (err) {\n        onError(err);\n      }\n    };\n    const bailIfEnded = bailSignal => {\n      const bailResult =\n      // The `cancel` prop or `stop` method was used.\n      callId <= (state.cancelId || 0) && getCancelledResult(target) ||\n      // The async `to` prop was replaced.\n      callId !== state.asyncId && getFinishedResult(target, false);\n      if (bailResult) {\n        bailSignal.result = bailResult;\n        throw bailSignal;\n      }\n    }; // Note: This function cannot use the `async` keyword, because we want the\n    // `throw` statements to interrupt the caller.\n\n    const animate = withBailHandler((arg1, arg2) => {\n      const bailSignal = new BailSignal();\n      bailIfEnded(bailSignal);\n      const props = is.obj(arg1) ? _extends({}, arg1) : _extends(_extends({}, arg2), {}, {\n        to: arg1\n      });\n      props.parentId = callId;\n      each(defaultProps, (value, key) => {\n        if (is.und(props[key])) {\n          props[key] = value;\n        }\n      });\n      return target.start(props).then(async result => {\n        bailIfEnded(bailSignal);\n        if (target.is('PAUSED')) {\n          await new Promise(resume => {\n            state.resumeQueue.add(resume);\n          });\n        }\n        return result;\n      });\n    });\n    let result;\n    try {\n      let animating; // Async sequence\n\n      if (is.arr(to)) {\n        animating = (async queue => {\n          for (const props of queue) {\n            await animate(props);\n          }\n        })(to);\n      } // Async script\n      else if (is.fun(to)) {\n        animating = Promise.resolve(to(animate, target.stop.bind(target)));\n      }\n      await Promise.all([animating.then(preventBail), bailPromise]);\n      result = getFinishedResult(target, true); // Bail handling\n    } catch (err) {\n      if (err instanceof BailSignal) {\n        result = err.result;\n      } else {\n        throw err;\n      } // Reset the async state.\n    } finally {\n      if (callId == state.asyncId) {\n        state.asyncId = parentId;\n        state.asyncTo = parentId ? prevTo : undefined;\n        state.promise = parentId ? prevPromise : undefined;\n      }\n    }\n    if (is.fun(onRest)) {\n      batchedUpdates(() => {\n        onRest(result);\n      });\n    }\n    return result;\n  })();\n}\nfunction cancelAsync(state, callId) {\n  state.cancelId = callId;\n  state.asyncId = state.asyncTo = state.promise = undefined;\n}\n/** This error is thrown to signal an interrupted async animation. */\n\nclass BailSignal extends Error {\n  constructor() {\n    super('An async animation has been interrupted. You see this error because you ' + 'forgot to use `await` or `.catch(...)` on its returned promise.');\n    this.result = void 0;\n  }\n}\nconst isFrameValue = value => value instanceof FrameValue;\nlet nextId = 1;\n/**\n * A kind of `FluidValue` that manages an `AnimatedValue` node.\n *\n * Its underlying value can be accessed and even observed.\n */\n\nclass FrameValue extends FluidValue {\n  constructor() {\n    super(...arguments);\n    this.id = nextId++;\n    this.key = void 0;\n    this._priority = 0;\n    this._children = new Set();\n  }\n  get priority() {\n    return this._priority;\n  }\n  set priority(priority) {\n    if (this._priority != priority) {\n      this._priority = priority;\n      this._onPriorityChange(priority);\n    }\n  }\n  /** Get the current value */\n\n  get() {\n    const node = getAnimated(this);\n    return node && node.getValue();\n  }\n  /** Create a spring that maps our value to another value */\n\n  to() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return to$1(this, args);\n  }\n  /** @deprecated Use the `to` method instead. */\n\n  interpolate() {\n    deprecateInterpolate();\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    return to$1(this, args);\n  }\n  /** @internal */\n\n  /** @internal */\n  addChild(child) {\n    if (!this._children.size) this._attach();\n    this._children.add(child);\n  }\n  /** @internal */\n\n  removeChild(child) {\n    this._children.delete(child);\n    if (!this._children.size) this._detach();\n  }\n  /** @internal */\n\n  onParentChange(_ref3) {\n    let {\n      type\n    } = _ref3;\n    if (this.idle) {\n      // Start animating when a parent does.\n      if (type == 'start') {\n        this._reset();\n        this._start();\n      }\n    } // Reset our animation state when a parent does, but only when\n    // our animation is active.\n    else if (type == 'reset') {\n      this._reset();\n    }\n  }\n  /** Called when the first child is added. */\n\n  _attach() {}\n  /** Called when the last child is removed. */\n\n  _detach() {}\n  /**\n   * Reset our animation state (eg: start values, velocity, etc)\n   * and tell our children to do the same.\n   *\n   * This is called when our goal value is changed during (or before)\n   * an animation.\n   */\n\n  _reset() {\n    this._emit({\n      type: 'reset',\n      parent: this\n    });\n  }\n  /**\n   * Start animating if possible.\n   *\n   * Note: Be sure to call `_reset` first, or the animation will break.\n   * This method would like to call `_reset` for you, but that would\n   * interfere with paused animations.\n   */\n\n  _start() {\n    this._emit({\n      type: 'start',\n      parent: this\n    });\n  }\n  /** Tell our children about our new value */\n\n  _onChange(value) {\n    let idle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this._emit({\n      type: 'change',\n      parent: this,\n      value,\n      idle\n    });\n  }\n  /** Tell our children about our new priority */\n\n  _onPriorityChange(priority) {\n    if (!this.idle) {\n      // Make the frameloop aware of our new priority.\n      frameLoop.start(this);\n    }\n    this._emit({\n      type: 'priority',\n      parent: this,\n      priority\n    });\n  }\n  _emit(event) {\n    // Clone \"_children\" so it can be safely mutated inside the loop.\n    each(Array.from(this._children), child => {\n      child.onParentChange(event);\n    });\n  }\n}\n\n// TODO: use \"const enum\" when Babel supports it\n\n/** The spring has not animated yet */\nconst CREATED = 'CREATED';\n/** The spring has animated before */\n\nconst IDLE = 'IDLE';\n/** The spring is animating */\n\nconst ACTIVE = 'ACTIVE';\n/** The spring is frozen in time */\n\nconst PAUSED = 'PAUSED';\n/** The spring cannot be animated */\n\nconst DISPOSED = 'DISPOSED';\n\n/**\n * Only numbers, strings, and arrays of numbers/strings are supported.\n * Non-animatable strings are also supported.\n */\nclass SpringValue extends FrameValue {\n  /** The property name used when `to` or `from` is an object. Useful when debugging too. */\n\n  /** The animation state */\n\n  /** The queue of pending props */\n\n  /** The lifecycle phase of this spring */\n\n  /** The state for `runAsync` calls */\n\n  /** Some props have customizable default values */\n\n  /** The counter for tracking `scheduleProps` calls */\n\n  /** The last `scheduleProps` call that changed the `to` prop */\n  constructor(arg1, arg2) {\n    super();\n    this.key = void 0;\n    this.animation = new Animation();\n    this.queue = void 0;\n    this._phase = CREATED;\n    this._state = {\n      pauseQueue: new Set(),\n      resumeQueue: new Set()\n    };\n    this._defaultProps = {};\n    this._lastCallId = 0;\n    this._lastToId = 0;\n    if (!is.und(arg1) || !is.und(arg2)) {\n      const props = is.obj(arg1) ? _extends({}, arg1) : _extends(_extends({}, arg2), {}, {\n        from: arg1\n      });\n      props.default = true;\n      this.start(props);\n    }\n  }\n  get idle() {\n    return !this.is(ACTIVE) && !this._state.asyncTo;\n  }\n  get goal() {\n    return getFluidValue(this.animation.to);\n  }\n  get velocity() {\n    const node = getAnimated(this);\n    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map(node => node.lastVelocity || 0);\n  }\n  /** Advance the current animation by a number of milliseconds */\n\n  advance(dt) {\n    let idle = true;\n    let changed = false;\n    const anim = this.animation;\n    let {\n      config,\n      toValues\n    } = anim;\n    const payload = getPayload(anim.to);\n    if (!payload) {\n      const toConfig = getFluidConfig(anim.to);\n      if (toConfig) {\n        toValues = toArray(toConfig.get());\n      }\n    }\n    anim.values.forEach((node, i) => {\n      if (node.done) return; // The \"anim.toValues\" array must exist when no parent exists.\n\n      let to = payload ? payload[i].lastPosition : toValues[i];\n      let finished = anim.immediate;\n      let position = to;\n      if (!finished) {\n        position = node.lastPosition; // Loose springs never move.\n\n        if (config.tension <= 0) {\n          node.done = true;\n          return;\n        }\n        const elapsed = node.elapsedTime += dt;\n        const from = anim.fromValues[i];\n        const v0 = node.v0 != null ? node.v0 : node.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n        let velocity; // Duration easing\n\n        if (!is.und(config.duration)) {\n          let p = config.progress || 0;\n          if (config.duration <= 0) p = 1;else p += (1 - p) * Math.min(1, elapsed / config.duration);\n          position = from + config.easing(p) * (to - from);\n          velocity = (position - node.lastPosition) / dt;\n          finished = p == 1;\n        } // Decay easing\n        else if (config.decay) {\n          const decay = config.decay === true ? 0.998 : config.decay;\n          const e = Math.exp(-(1 - decay) * elapsed);\n          position = from + v0 / (1 - decay) * (1 - e);\n          finished = Math.abs(node.lastPosition - position) < 0.1; // derivative of position\n\n          velocity = v0 * e;\n        } // Spring easing\n        else {\n          velocity = node.lastVelocity == null ? v0 : node.lastVelocity;\n          /** The smallest distance from a value before being treated like said value. */\n\n          const precision = config.precision || (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001));\n          /** The velocity at which movement is essentially none */\n\n          const restVelocity = config.restVelocity || precision / 10; // Bouncing is opt-in (not to be confused with overshooting)\n\n          const bounceFactor = config.clamp ? 0 : config.bounce;\n          const canBounce = !is.und(bounceFactor);\n          /** When `true`, the value is increasing over time */\n\n          const isGrowing = from == to ? node.v0 > 0 : from < to;\n          /** When `true`, the velocity is considered moving */\n\n          let isMoving;\n          /** When `true`, the velocity is being deflected or clamped */\n\n          let isBouncing = false;\n          const step = 1; // 1ms\n\n          const numSteps = Math.ceil(dt / step);\n          for (let n = 0; n < numSteps; ++n) {\n            isMoving = Math.abs(velocity) > restVelocity;\n            if (!isMoving) {\n              finished = Math.abs(to - position) <= precision;\n              if (finished) {\n                break;\n              }\n            }\n            if (canBounce) {\n              isBouncing = position == to || position > to == isGrowing; // Invert the velocity with a magnitude, or clamp it.\n\n              if (isBouncing) {\n                velocity = -velocity * bounceFactor;\n                position = to;\n              }\n            }\n            const springForce = -config.tension * 0.000001 * (position - to);\n            const dampingForce = -config.friction * 0.001 * velocity;\n            const acceleration = (springForce + dampingForce) / config.mass; // pt/ms^2\n\n            velocity = velocity + acceleration * step; // pt/ms\n\n            position = position + velocity * step;\n          }\n        }\n        node.lastVelocity = velocity;\n        if (Number.isNaN(position)) {\n          console.warn(\"Got NaN while animating:\", this);\n          finished = true;\n        }\n      } // Parent springs must finish before their children can.\n\n      if (payload && !payload[i].done) {\n        finished = false;\n      }\n      if (finished) {\n        node.done = true;\n      } else {\n        idle = false;\n      }\n      if (node.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n    if (idle) {\n      this.finish();\n    } else if (changed) {\n      this._onChange(this.get());\n    }\n    return idle;\n  }\n  /** Check the current phase */\n\n  is(phase) {\n    return this._phase == phase;\n  }\n  /** Set the current value, while stopping the current animation */\n\n  set(value) {\n    batchedUpdates(() => {\n      this._focus(value);\n      if (this._set(value)) {\n        // Ensure change observers are notified. When active,\n        // the \"_stop\" method handles this.\n        if (!this.is(ACTIVE)) {\n          return this._onChange(this.get(), true);\n        }\n      }\n      this._stop();\n    });\n    return this;\n  }\n  /**\n   * Freeze the active animation in time.\n   * This does nothing when not animating.\n   */\n\n  pause() {\n    checkDisposed(this, 'pause');\n    if (!this.is(PAUSED)) {\n      this._phase = PAUSED;\n      flush(this._state.pauseQueue, onPause => onPause());\n    }\n  }\n  /** Resume the animation if paused. */\n\n  resume() {\n    checkDisposed(this, 'resume');\n    if (this.is(PAUSED)) {\n      this._start();\n      flush(this._state.resumeQueue, onResume => onResume());\n    }\n  }\n  /**\n   * Skip to the end of the current animation.\n   *\n   * All `onRest` callbacks are passed `{finished: true}`\n   */\n\n  finish(to) {\n    this.resume();\n    if (this.is(ACTIVE)) {\n      const anim = this.animation; // Decay animations have an implicit goal.\n\n      if (!anim.config.decay && is.und(to)) {\n        to = anim.to;\n      } // Set the value if we can.\n\n      if (!is.und(to)) {\n        this._set(to);\n      }\n      batchedUpdates(() => {\n        // Ensure the \"onStart\" and \"onRest\" props are called.\n        if (!anim.changed) {\n          anim.changed = true;\n          if (anim.onStart) {\n            anim.onStart(this);\n          }\n        } // Exit the frameloop.\n\n        this._stop();\n      });\n    }\n    return this;\n  }\n  /** Push props into the pending queue. */\n\n  update(props) {\n    checkDisposed(this, 'update');\n    const queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n  /**\n   * Update this value's animation using the queue of pending props,\n   * and unpause the current animation (if one is frozen).\n   *\n   * When arguments are passed, a new animation is created, and the\n   * queued animations are left alone.\n   */\n\n  async start(to, arg2) {\n    checkDisposed(this, 'start');\n    let queue;\n    if (!is.und(to)) {\n      queue = [is.obj(to) ? to : _extends(_extends({}, arg2), {}, {\n        to\n      })];\n    } else {\n      queue = this.queue || [];\n      this.queue = [];\n    }\n    const results = await Promise.all(queue.map(props => this._update(props)));\n    return getCombinedResult(this, results);\n  }\n  /**\n   * Stop the current animation, and cancel any delayed updates.\n   *\n   * Pass `true` to call `onRest` with `cancelled: true`.\n   */\n\n  stop(cancel) {\n    if (!this.is(DISPOSED)) {\n      cancelAsync(this._state, this._lastCallId); // Ensure the `to` value equals the current value.\n\n      this._focus(this.get()); // Exit the frameloop and notify `onRest` listeners.\n\n      batchedUpdates(() => this._stop(cancel));\n    }\n    return this;\n  }\n  /** Restart the animation. */\n\n  reset() {\n    this._update({\n      reset: true\n    });\n  }\n  /** Prevent future animations, and stop the current animation */\n\n  dispose() {\n    if (!this.is(DISPOSED)) {\n      if (this.animation) {\n        // Prevent \"onRest\" calls when disposed.\n        this.animation.onRest = [];\n      }\n      this.stop();\n      this._phase = DISPOSED;\n    }\n  }\n  /** @internal */\n\n  onParentChange(event) {\n    super.onParentChange(event);\n    if (event.type == 'change') {\n      if (!this.is(ACTIVE)) {\n        this._reset();\n        if (!this.is(PAUSED)) {\n          this._start();\n        }\n      }\n    } else if (event.type == 'priority') {\n      this.priority = event.priority + 1;\n    }\n  }\n  /**\n   * Parse the `to` and `from` range from the given `props` object.\n   *\n   * This also ensures the initial value is available to animated components\n   * during the render phase.\n   */\n\n  _prepareNode(_ref4) {\n    let {\n      to,\n      from,\n      reverse\n    } = _ref4;\n    const key = this.key || '';\n    to = !is.obj(to) || getFluidConfig(to) ? to : to[key];\n    from = !is.obj(from) || getFluidConfig(from) ? from : from[key]; // Create the range now to avoid \"reverse\" logic.\n\n    const range = {\n      to,\n      from\n    }; // Before ever animating, this method ensures an `Animated` node\n    // exists and keeps its value in sync with the \"from\" prop.\n\n    if (this.is(CREATED)) {\n      if (reverse) [to, from] = [from, to];\n      from = getFluidValue(from);\n      const node = this._updateNode(is.und(from) ? getFluidValue(to) : from);\n      if (node && !is.und(from)) {\n        node.setValue(from);\n      }\n    }\n    return range;\n  }\n  /**\n   * Create an `Animated` node if none exists or the given value has an\n   * incompatible type. Do nothing if `value` is undefined.\n   *\n   * The newest `Animated` node is returned.\n   */\n\n  _updateNode(value) {\n    let node = getAnimated(this);\n    if (!is.und(value)) {\n      const nodeType = this._getNodeType(value);\n      if (!node || node.constructor !== nodeType) {\n        setAnimated(this, node = nodeType.create(value));\n      }\n    }\n    return node;\n  }\n  /** Return the `Animated` node constructor for a given value */\n\n  _getNodeType(value) {\n    const parentNode = getAnimated(value);\n    return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  }\n  /** Schedule an animation to run after an optional delay */\n\n  _update(props, isLoop) {\n    const defaultProps = this._defaultProps;\n    const mergeDefaultProp = key => {\n      const value = getDefaultProp(props, key);\n      if (!is.und(value)) {\n        defaultProps[key] = value;\n      } // For `cancel` and `pause`, a truthy default always wins.\n\n      if (defaultProps[key]) {\n        props[key] = defaultProps[key];\n      }\n    }; // These props are coerced into booleans by the `scheduleProps` function,\n    // so they need their default values processed before then.\n\n    mergeDefaultProp('cancel');\n    mergeDefaultProp('pause'); // Ensure the initial value can be accessed by animated components.\n\n    const range = this._prepareNode(props);\n    return scheduleProps(++this._lastCallId, {\n      key: this.key,\n      props,\n      state: this._state,\n      actions: {\n        pause: this.pause.bind(this),\n        resume: this.resume.bind(this),\n        start: this._merge.bind(this, range)\n      }\n    }).then(result => {\n      if (props.loop && result.finished && !(isLoop && result.noop)) {\n        const nextProps = createLoopUpdate(props);\n        if (nextProps) {\n          return this._update(nextProps, true);\n        }\n      }\n      return result;\n    });\n  }\n  /** Merge props into the current animation */\n\n  _merge(range, props, resolve) {\n    // The \"cancel\" prop cancels all pending delays and it forces the\n    // active animation to stop where it is.\n    if (props.cancel) {\n      this.stop(true);\n      return resolve(getCancelledResult(this));\n    }\n    const {\n      key,\n      animation: anim\n    } = this;\n    const defaultProps = this._defaultProps;\n    /** The \"to\" prop is defined. */\n\n    const hasToProp = !is.und(range.to);\n    /** The \"from\" prop is defined. */\n\n    const hasFromProp = !is.und(range.from); // Avoid merging other props if implicitly prevented, except\n    // when both the \"to\" and \"from\" props are undefined.\n\n    if (hasToProp || hasFromProp) {\n      if (props.callId > this._lastToId) {\n        this._lastToId = props.callId;\n      } else {\n        return resolve(getCancelledResult(this));\n      }\n    }\n    /** Get the value of a prop, or its default value */\n\n    const get = prop => !is.und(props[prop]) ? props[prop] : defaultProps[prop]; // Call \"onDelayEnd\" before merging props, but after cancellation checks.\n\n    const onDelayEnd = coerceEventProp(get('onDelayEnd'), key);\n    if (onDelayEnd) {\n      onDelayEnd(props, this);\n    }\n    if (props.default) {\n      mergeDefaultProps(defaultProps, props, ['pause', 'cancel']);\n    }\n    const {\n      to: prevTo,\n      from: prevFrom\n    } = anim;\n    let {\n      to = prevTo,\n      from = prevFrom\n    } = range; // Focus the \"from\" value if changing without a \"to\" value.\n\n    if (hasFromProp && !hasToProp) {\n      to = from;\n    } // Flip the current range if \"reverse\" is true.\n\n    if (props.reverse) [to, from] = [from, to];\n    /** The \"from\" value is changing. */\n\n    const hasFromChanged = !isEqual(from, prevFrom);\n    if (hasFromChanged) {\n      anim.from = from;\n    }\n    /** The \"to\" value is changing. */\n\n    const hasToChanged = !isEqual(to, prevTo);\n    if (hasToChanged) {\n      this._focus(to);\n    } // Both \"from\" and \"to\" can use a fluid config (thanks to http://npmjs.org/fluids).\n\n    const toConfig = getFluidConfig(to);\n    const fromConfig = getFluidConfig(from);\n    if (fromConfig) {\n      from = fromConfig.get();\n    }\n    /** The \"to\" prop is async. */\n\n    const hasAsyncTo = is.arr(props.to) || is.fun(props.to);\n    const {\n      config\n    } = anim;\n    const {\n      decay,\n      velocity\n    } = config; // The \"runAsync\" function treats the \"config\" prop as a default,\n    // so we must avoid merging it when the \"to\" prop is async.\n\n    if (props.config && !hasAsyncTo) {\n      mergeConfig(config, callProp(props.config, key),\n      // Avoid calling the same \"config\" prop twice.\n      props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);\n    } // This instance might not have its Animated node yet. For example,\n    // the constructor can be given props without a \"to\" or \"from\" value.\n\n    let node = getAnimated(this);\n    if (!node || is.und(to)) {\n      return resolve(getFinishedResult(this, true));\n    }\n    /** When true, start at the \"from\" value. */\n\n    const reset =\n    // When `reset` is undefined, the `from` prop implies `reset: true`,\n    // except for declarative updates. When `reset` is defined, there\n    // must exist a value to animate from.\n    is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key); // The current value, where the animation starts from.\n\n    const value = reset ? from : this.get(); // The animation ends at this value, unless \"to\" is fluid.\n\n    const goal = computeGoal(to); // Only specific types can be animated to/from.\n\n    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal); // When true, the value changes instantly on the next frame.\n\n    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));\n    if (hasToChanged) {\n      if (immediate) {\n        node = this._updateNode(goal);\n      } else {\n        const nodeType = this._getNodeType(to);\n        if (nodeType !== node.constructor) {\n          throw Error(\"Cannot animate between \" + node.constructor.name + \" and \" + nodeType.name + \", as the \\\"to\\\" prop suggests\");\n        }\n      }\n    } // The type of Animated node for the goal value.\n\n    const goalType = node.constructor; // When the goal value is fluid, we don't know if its value\n    // will change before the next animation frame, so it always\n    // starts the animation to be safe.\n\n    let started = !!toConfig;\n    let finished = false;\n    if (!started) {\n      // When true, the current value has probably changed.\n      const hasValueChanged = reset || this.is(CREATED) && hasFromChanged; // When the \"to\" value or current value are changed,\n      // start animating if not already finished.\n\n      if (hasToChanged || hasValueChanged) {\n        finished = isEqual(computeGoal(value), goal);\n        started = !finished;\n      } // Changing \"decay\" or \"velocity\" starts the animation.\n\n      if (!isEqual(config.decay, decay) || !isEqual(config.velocity, velocity)) {\n        started = true;\n      }\n    } // When an active animation changes its goal to its current value:\n\n    if (finished && this.is(ACTIVE)) {\n      // Avoid an abrupt stop unless the animation is being reset.\n      if (anim.changed && !reset) {\n        started = true;\n      } // Stop the animation before its first frame.\n      else if (!started) {\n        this._stop();\n      }\n    }\n    if (!hasAsyncTo) {\n      // Make sure our \"toValues\" are updated even if our previous\n      // \"to\" prop is a fluid value whose current value is also ours.\n      if (started || getFluidConfig(prevTo)) {\n        anim.values = node.getPayload();\n        anim.toValues = toConfig ? null : goalType == AnimatedString ? [1] : toArray(goal);\n      }\n      anim.immediate = immediate;\n      anim.onStart = coerceEventProp(get('onStart'), key);\n      anim.onChange = coerceEventProp(get('onChange'), key); // The \"reset\" prop tries to reuse the old \"onRest\" prop,\n      // unless you defined a new \"onRest\" prop.\n\n      const onRestQueue = anim.onRest;\n      const onRest = reset && !props.onRest ? onRestQueue[0] || noop : checkFinishedOnRest(coerceEventProp(get('onRest'), key), this); // In most cases, the animation after this one won't reuse our\n      // \"onRest\" prop. Instead, the _default_ \"onRest\" prop is used\n      // when the next animation has an undefined \"onRest\" prop.\n\n      if (started) {\n        anim.onRest = [onRest, checkFinishedOnRest(resolve, this)]; // Flush the \"onRest\" queue for the previous animation.\n\n        let onRestIndex = reset ? 0 : 1;\n        if (onRestIndex < onRestQueue.length) {\n          batchedUpdates(() => {\n            for (; onRestIndex < onRestQueue.length; onRestIndex++) {\n              onRestQueue[onRestIndex]();\n            }\n          });\n        }\n      } // The \"onRest\" prop is always first, and it can be updated even\n      // if a new animation is not started by this update.\n      else if (reset || props.onRest) {\n        anim.onRest[0] = onRest;\n      }\n    } // By this point, every prop has been merged.\n\n    const onProps = coerceEventProp(get('onProps'), key);\n    if (onProps) {\n      onProps(props, this);\n    } // Update our node even if the animation is idle.\n\n    if (reset) {\n      node.setValue(value);\n    }\n    if (hasAsyncTo) {\n      resolve(runAsync(props.to, props, this._state, this));\n    } // Start an animation\n    else if (started) {\n      // Must be idle for \"onStart\" to be called again.\n      if (reset) this._phase = IDLE;\n      this._reset();\n      this._start();\n    } // Postpone promise resolution until the animation is finished,\n    // so that no-op updates still resolve at the expected time.\n    else if (this.is(ACTIVE) && !hasToChanged) {\n      anim.onRest.push(checkFinishedOnRest(resolve, this));\n    } // Resolve our promise immediately.\n    else {\n      resolve(getNoopResult(this, value));\n    }\n  }\n  /** Update the `animation.to` value, which might be a `FluidValue` */\n\n  _focus(value) {\n    const anim = this.animation;\n    if (value !== anim.to) {\n      let config = getFluidConfig(anim.to);\n      if (config) {\n        config.removeChild(this);\n      }\n      anim.to = value;\n      let priority = 0;\n      if (config = getFluidConfig(value)) {\n        config.addChild(this);\n        if (isFrameValue(value)) {\n          priority = (value.priority || 0) + 1;\n        }\n      }\n      this.priority = priority;\n    }\n  }\n  /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */\n\n  _set(value) {\n    const config = getFluidConfig(value);\n    if (config) {\n      value = config.get();\n    }\n    const node = getAnimated(this);\n    const oldValue = node && node.getValue();\n    if (node) {\n      node.setValue(value);\n    } else {\n      this._updateNode(value);\n    }\n    return !isEqual(value, oldValue);\n  }\n  _onChange(value) {\n    let idle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const anim = this.animation; // The \"onStart\" prop is called on the first change after entering the\n    // frameloop, but never for immediate animations.\n\n    if (!anim.changed && !idle) {\n      anim.changed = true;\n      if (anim.onStart) {\n        anim.onStart(this);\n      }\n    }\n    if (anim.onChange) {\n      anim.onChange(value, this);\n    }\n    super._onChange(value, idle);\n  }\n  _reset() {\n    const anim = this.animation; // Reset the state of each Animated node.\n\n    getAnimated(this).reset(anim.to); // Ensure the `onStart` prop will be called.\n\n    if (!this.is(ACTIVE)) {\n      anim.changed = false;\n    } // Use the current values as the from values.\n\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map(node => node.lastPosition);\n    }\n    super._reset();\n  }\n  _start() {\n    if (!this.is(ACTIVE)) {\n      this._phase = ACTIVE;\n      super._start(); // The \"skipAnimation\" global avoids the frameloop.\n\n      if (skipAnimation) {\n        this.finish();\n      } else {\n        frameLoop.start(this);\n      }\n    }\n  }\n  /**\n   * Exit the frameloop and notify `onRest` listeners.\n   *\n   * Always wrap `_stop` calls with `batchedUpdates`.\n   */\n\n  _stop(cancel) {\n    this.resume();\n    if (this.is(ACTIVE)) {\n      this._phase = IDLE; // Always let change observers know when a spring becomes idle.\n\n      this._onChange(this.get(), true);\n      const anim = this.animation;\n      each(anim.values, node => {\n        node.done = true;\n      });\n      const onRestQueue = anim.onRest;\n      if (onRestQueue.length) {\n        // Preserve the \"onRest\" prop when the goal is dynamic.\n        anim.onRest = [anim.toValues ? noop : onRestQueue[0]]; // Never call the \"onRest\" prop for no-op animations.\n\n        if (!anim.changed) {\n          onRestQueue[0] = noop;\n        }\n        each(onRestQueue, onRest => onRest(cancel));\n      }\n    }\n  }\n}\nfunction checkDisposed(spring, name) {\n  if (spring.is(DISPOSED)) {\n    throw Error(\"Cannot call \\\"\" + name + \"\\\" of disposed \\\"\" + spring.constructor.name + \"\\\" object\");\n  }\n}\n/** Coerce an event prop to an event handler */\n\nfunction coerceEventProp(prop, key) {\n  return is.fun(prop) ? prop : key && prop ? prop[key] : undefined;\n}\n/**\n * The \"finished\" value is determined by each \"onRest\" handler,\n * based on whether the current value equals the goal value that\n * was calculated at the time the \"onRest\" handler was set.\n */\n\nconst checkFinishedOnRest = (onRest, spring) => {\n  const {\n    to\n  } = spring.animation;\n  return onRest ? cancel => {\n    if (cancel) {\n      onRest(getCancelledResult(spring));\n    } else {\n      const goal = computeGoal(to);\n      const value = computeGoal(spring.get());\n      const finished = isEqual(value, goal);\n      onRest(getFinishedResult(spring, finished));\n    }\n  } : noop;\n};\nfunction createLoopUpdate(props) {\n  let loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : props.loop;\n  let to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : props.to;\n  let loopRet = callProp(loop);\n  if (loopRet) {\n    const overrides = loopRet !== true && inferTo(loopRet);\n    const reverse = (overrides || props).reverse;\n    const reset = !overrides || overrides.reset;\n    return createUpdate(_extends(_extends({}, props), {}, {\n      loop,\n      // Avoid updating default props when looping.\n      default: false,\n      // For the \"reverse\" prop to loop as expected, the \"to\" prop\n      // must be undefined. The \"reverse\" prop is ignored when the\n      // \"to\" prop is an array or function.\n      to: !reverse || is.arr(to) || is.fun(to) ? to : undefined,\n      // Avoid defining the \"from\" prop if a reset is unwanted.\n      from: reset ? props.from : undefined,\n      reset\n    }, overrides));\n  }\n}\n/**\n * Return a new object based on the given `props`.\n *\n * - All unreserved props are moved into the `to` prop object.\n * - The `to` and `from` props are deleted when falsy.\n * - The `keys` prop is set to an array of affected keys,\n *   or `null` if all keys are affected.\n */\n\nfunction createUpdate(props) {\n  const {\n    to,\n    from\n  } = props = inferTo(props); // Collect the keys affected by this update.\n\n  const keys = new Set();\n  if (from) {\n    findDefined(from, keys);\n  } else {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.from;\n  }\n  if (is.obj(to)) {\n    findDefined(to, keys);\n  } else if (!to) {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.to;\n  } // The \"keys\" prop helps in applying updates to affected keys only.\n\n  props.keys = keys.size ? Array.from(keys) : null;\n  return props;\n}\n/**\n * A modified version of `createUpdate` meant for declarative APIs.\n */\n\nfunction declareUpdate(props) {\n  const update = createUpdate(props);\n  if (is.und(update.default)) {\n    update.default = getDefaultProps(update, [\n    // Avoid forcing `immediate: true` onto imperative updates.\n    update.immediate === true && 'immediate']);\n  }\n  return update;\n}\n/** Find keys with defined values */\n\nfunction findDefined(values, keys) {\n  each(values, (value, key) => value != null && keys.add(key));\n}\n\n/** Events batched by the `Controller` class */\nconst BATCHED_EVENTS = ['onStart', 'onChange', 'onRest'];\nlet nextId$1 = 1;\n/** Queue of pending updates for a `Controller` instance. */\n\nclass Controller {\n  /** The animated values */\n\n  /** The queue of props passed to the `update` method. */\n\n  /** Custom handler for flushing update queues */\n\n  /** These props are used by all future spring values */\n\n  /** The combined phase of our spring values */\n\n  /** The counter for tracking `scheduleProps` calls */\n\n  /** The values currently being animated */\n\n  /** State used by the `runAsync` function */\n\n  /** The event queues that are flushed once per frame maximum */\n  constructor(props, flush) {\n    this.id = nextId$1++;\n    this.springs = {};\n    this.queue = [];\n    this._flush = void 0;\n    this._initialProps = void 0;\n    this._phase = CREATED;\n    this._lastAsyncId = 0;\n    this._active = new Set();\n    this._state = {\n      pauseQueue: new Set(),\n      resumeQueue: new Set()\n    };\n    this._events = {\n      onStart: new Set(),\n      onChange: new Set(),\n      onRest: new Map()\n    };\n    this._onFrame = this._onFrame.bind(this);\n    if (flush) {\n      this._flush = flush;\n    }\n    if (props) {\n      this.start(props);\n    }\n  }\n  /**\n   * Equals `true` when no spring values are in the frameloop, and\n   * no async animation is currently active.\n   */\n\n  get idle() {\n    return !this._state.asyncTo && Object.values(this.springs).every(spring => spring.idle);\n  }\n  /** Check the current phase */\n\n  is(phase) {\n    return this._phase == phase;\n  }\n  /** Get the current values of our springs */\n\n  get() {\n    const values = {};\n    this.each((spring, key) => values[key] = spring.get());\n    return values;\n  }\n  /** Push an update onto the queue of each value. */\n\n  update(props) {\n    if (props) this.queue.push(createUpdate(props));\n    return this;\n  }\n  /**\n   * Start the queued animations for every spring, and resolve the returned\n   * promise once all queued animations have finished or been cancelled.\n   *\n   * When you pass a queue (instead of nothing), that queue is used instead of\n   * the queued animations added with the `update` method, which are left alone.\n   */\n\n  start(props) {\n    const queue = props ? toArray(props).map(createUpdate) : this.queue;\n    if (!props) {\n      this.queue = [];\n    }\n    if (this._flush) {\n      return this._flush(this, queue);\n    }\n    prepareKeys(this, queue);\n    return flushUpdateQueue(this, queue);\n  }\n  /** Stop one animation, some animations, or all animations */\n\n  stop(keys) {\n    if (is.und(keys)) {\n      this.each(spring => spring.stop());\n      cancelAsync(this._state, this._lastAsyncId);\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].stop());\n    }\n    return this;\n  }\n  /** Freeze the active animation in time */\n\n  pause(keys) {\n    if (is.und(keys)) {\n      this.each(spring => spring.pause());\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].pause());\n    }\n    return this;\n  }\n  /** Resume the animation if paused. */\n\n  resume(keys) {\n    if (is.und(keys)) {\n      this.each(spring => spring.resume());\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].resume());\n    }\n    return this;\n  }\n  /** Restart every animation. */\n\n  reset() {\n    this.each(spring => spring.reset()); // TODO: restart async \"to\" prop\n\n    return this;\n  }\n  /** Call a function once per spring value */\n\n  each(iterator) {\n    each(this.springs, iterator);\n  }\n  /** Destroy every spring in this controller */\n\n  dispose() {\n    this._state.asyncTo = undefined;\n    this.each(spring => spring.dispose());\n    this.springs = {};\n  }\n  /** @internal Called at the end of every animation frame */\n\n  _onFrame() {\n    const {\n      onStart,\n      onChange,\n      onRest\n    } = this._events;\n    const isActive = this._active.size > 0;\n    if (isActive && this._phase != ACTIVE) {\n      this._phase = ACTIVE;\n      flush(onStart, onStart => onStart(this));\n    }\n    const values = (onChange.size || !isActive && onRest.size) && this.get();\n    flush(onChange, onChange => onChange(values)); // The \"onRest\" queue is only flushed when all springs are idle.\n\n    if (!isActive) {\n      this._phase = IDLE;\n      flush(onRest, _ref5 => {\n        let [onRest, result] = _ref5;\n        result.value = values;\n        onRest(result);\n      });\n    }\n  }\n  /** @internal */\n\n  onParentChange(event) {\n    if (event.type == 'change') {\n      this._active[event.idle ? 'delete' : 'add'](event.parent);\n      frameLoop.onFrame(this._onFrame);\n    }\n  }\n}\n/**\n * Warning: Props might be mutated.\n */\n\nfunction flushUpdateQueue(ctrl, queue) {\n  return Promise.all(queue.map(props => flushUpdate(ctrl, props))).then(results => getCombinedResult(ctrl, results));\n}\n/**\n * Warning: Props might be mutated.\n *\n * Process a single set of props using the given controller.\n *\n * The returned promise resolves to `true` once the update is\n * applied and any animations it starts are finished without being\n * stopped or cancelled.\n */\n\nfunction flushUpdate(ctrl, props, isLoop) {\n  const {\n    to,\n    loop,\n    onRest\n  } = props; // Looping must be handled in this function, or else the values\n  // would end up looping out-of-sync in many common cases.\n\n  if (loop) {\n    props.loop = false;\n  }\n  const asyncTo = is.arr(to) || is.fun(to) ? to : undefined;\n  if (asyncTo) {\n    props.to = undefined;\n    props.onRest = undefined;\n  } else {\n    // For certain events, use batching to prevent multiple calls per frame.\n    // However, batching is avoided when the `to` prop is async, because any\n    // event props are used as default props instead.\n    each(BATCHED_EVENTS, key => {\n      const handler = props[key];\n      if (is.fun(handler)) {\n        const queue = ctrl['_events'][key];\n        if (queue instanceof Set) {\n          props[key] = () => queue.add(handler);\n        } else {\n          props[key] = _ref6 => {\n            let {\n              finished,\n              cancelled\n            } = _ref6;\n            const result = queue.get(handler);\n            if (result) {\n              if (!finished) result.finished = false;\n              if (cancelled) result.cancelled = true;\n            } else {\n              // The \"value\" is set before the \"handler\" is called.\n              queue.set(handler, {\n                value: null,\n                finished,\n                cancelled\n              });\n            }\n          };\n        }\n      }\n    });\n  }\n  const keys = props.keys || Object.keys(ctrl.springs);\n  const promises = keys.map(key => ctrl.springs[key].start(props)); // Schedule the \"asyncTo\" if defined.\n\n  const state = ctrl['_state'];\n  if (asyncTo) {\n    promises.push(scheduleProps(++ctrl['_lastAsyncId'], {\n      props,\n      state,\n      actions: {\n        pause: noop,\n        resume: noop,\n        start(props, resolve) {\n          props.onRest = onRest;\n          if (!props.cancel) {\n            resolve(runAsync(asyncTo, props, state, ctrl));\n          } // Prevent `cancel: true` from ending the current `runAsync` call,\n          // except when the default `cancel` prop is being set.\n          else if (hasDefaultProp(props, 'cancel')) {\n            cancelAsync(state, props.callId);\n          }\n        }\n      }\n    }));\n  } // Respect the `cancel` prop when no keys are affected.\n  else if (!props.keys && props.cancel === true) {\n    cancelAsync(state, ctrl['_lastAsyncId']);\n  }\n  return Promise.all(promises).then(results => {\n    const result = getCombinedResult(ctrl, results);\n    if (loop && result.finished && !(isLoop && result.noop)) {\n      const nextProps = createLoopUpdate(props, loop, to);\n      if (nextProps) {\n        prepareKeys(ctrl, [nextProps]);\n        return flushUpdate(ctrl, nextProps, true);\n      }\n    }\n    return result;\n  });\n}\n/**\n * From an array of updates, get the map of `SpringValue` objects\n * by their keys. Springs are created when any update wants to\n * animate a new key.\n *\n * Springs created by `getSprings` are neither cached nor observed\n * until they're given to `setSprings`.\n */\n\nfunction getSprings(ctrl, props) {\n  const springs = _extends({}, ctrl.springs);\n  if (props) {\n    each(toArray(props), props => {\n      if (is.und(props.keys)) {\n        props = createUpdate(props);\n      }\n      if (!is.obj(props.to)) {\n        // Avoid passing array/function to each spring.\n        props = _extends(_extends({}, props), {}, {\n          to: undefined\n        });\n      }\n      prepareSprings(springs, props, key => {\n        return createSpring(key);\n      });\n    });\n  }\n  return springs;\n}\n/**\n * Tell a controller to manage the given `SpringValue` objects\n * whose key is not already in use.\n */\n\nfunction setSprings(ctrl, springs) {\n  each(springs, (spring, key) => {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring;\n      spring.addChild(ctrl);\n    }\n  });\n}\nfunction createSpring(key, observer) {\n  const spring = new SpringValue();\n  spring.key = key;\n  if (observer) {\n    spring.addChild(observer);\n  }\n  return spring;\n}\n/**\n * Ensure spring objects exist for each defined key.\n *\n * Using the `props`, the `Animated` node of each `SpringValue` may\n * be created or updated.\n */\n\nfunction prepareSprings(springs, props, create) {\n  if (props.keys) {\n    each(props.keys, key => {\n      const spring = springs[key] || (springs[key] = create(key));\n      spring['_prepareNode'](props);\n    });\n  }\n}\n/**\n * Ensure spring objects exist for each defined key, and attach the\n * `ctrl` to them for observation.\n *\n * The queue is expected to contain `createUpdate` results.\n */\n\nfunction prepareKeys(ctrl, queue) {\n  each(queue, props => {\n    prepareSprings(ctrl.springs, props, key => {\n      return createSpring(key, ctrl);\n    });\n  });\n}\n\n/**\n * This context affects all new and existing `SpringValue` objects\n * created with the hook API or the renderprops API.\n */\n\nconst ctx = createContext({});\nconst SpringContext = _ref => {\n  let {\n      children\n    } = _ref,\n    props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n  const inherited = useContext(ctx); // Memoize the context to avoid unwanted renders.\n\n  props = useMemo(() => _extends(_extends({}, inherited), props), [inherited, props.pause, props.cancel, props.immediate, props.config]);\n  const {\n    Provider\n  } = ctx;\n  return /*#__PURE__*/createElement(Provider, {\n    value: props\n  }, children);\n};\nSpringContext.Provider = ctx.Provider;\nSpringContext.Consumer = ctx.Consumer;\n/** Get the current values of nearest `SpringContext` component. */\n\nconst useSpringContext = () => useContext(ctx);\n\n/** Create an imperative API for manipulating an array of `Controller` objects. */\nconst SpringHandle = {\n  create: getControllers => ({\n    get controllers() {\n      return getControllers();\n    },\n    update(props) {\n      each(getControllers(), (ctrl, i) => {\n        ctrl.update(getProps(props, i, ctrl));\n      });\n      return this;\n    },\n    async start(props) {\n      const results = await Promise.all(getControllers().map((ctrl, i) => {\n        const update = getProps(props, i, ctrl);\n        return ctrl.start(update);\n      }));\n      return {\n        value: results.map(result => result.value),\n        finished: results.every(result => result.finished)\n      };\n    },\n    stop: keys => each(getControllers(), ctrl => ctrl.stop(keys)),\n    pause: keys => each(getControllers(), ctrl => ctrl.pause(keys)),\n    resume: keys => each(getControllers(), ctrl => ctrl.resume(keys))\n  })\n};\n\n/** @internal */\nfunction useSprings(length, props, deps) {\n  const propsFn = is.fun(props) && props;\n  if (propsFn && !deps) deps = [];\n  // Set to 0 to prevent sync flush.\n  const layoutId = useRef(0);\n  const forceUpdate = useForceUpdate(); // State is updated on commit.\n\n  const [state] = useState(() => ({\n    ctrls: [],\n    queue: [],\n    flush(ctrl, updates) {\n      const springs = getSprings(ctrl, updates); // Flushing is postponed until the component's commit phase\n      // if a spring was created since the last commit.\n\n      const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs).some(key => !ctrl.springs[key]);\n      return canFlushSync ? flushUpdateQueue(ctrl, updates) : new Promise(resolve => {\n        setSprings(ctrl, springs);\n        state.queue.push(() => {\n          resolve(flushUpdateQueue(ctrl, updates));\n        });\n        forceUpdate();\n      });\n    }\n  })); // The imperative API ref from the props of the first controller.\n\n  const refProp = useRef();\n  const ctrls = [...state.ctrls];\n  const updates = []; // Cache old controllers to dispose in the commit phase.\n\n  const prevLength = usePrev(length) || 0;\n  const disposed = ctrls.slice(length, prevLength); // Create new controllers when \"length\" increases, and destroy\n  // the affected controllers when \"length\" decreases.\n\n  useMemo(() => {\n    ctrls.length = length;\n    declareUpdates(prevLength, length);\n  }, [length]); // Update existing controllers when \"deps\" are changed.\n\n  useMemo(() => {\n    declareUpdates(0, Math.min(prevLength, length));\n  }, deps);\n  /** Fill the `updates` array with declarative updates for the given index range. */\n\n  function declareUpdates(startIndex, endIndex) {\n    for (let i = startIndex; i < endIndex; i++) {\n      const ctrl = ctrls[i] || (ctrls[i] = new Controller(null, state.flush));\n      let update = propsFn ? propsFn(i, ctrl) : props[i];\n      if (update) {\n        update = updates[i] = declareUpdate(update);\n        if (i == 0) {\n          refProp.current = update.ref;\n          update.ref = undefined;\n        }\n      }\n    }\n  }\n  const api = useMemo$1(() => {\n    return SpringHandle.create(() => state.ctrls);\n  }, []); // New springs are created during render so users can pass them to\n  // their animated components, but new springs aren't cached until the\n  // commit phase (see the `useLayoutEffect` callback below).\n\n  const springs = ctrls.map((ctrl, i) => getSprings(ctrl, updates[i]));\n  const context = useSpringContext();\n  useLayoutEffect(() => {\n    layoutId.current++; // Replace the cached controllers.\n\n    state.ctrls = ctrls; // Update the ref prop.\n\n    if (refProp.current) {\n      refProp.current.current = api;\n    } // Flush the commit queue.\n\n    const {\n      queue\n    } = state;\n    if (queue.length) {\n      state.queue = [];\n      each(queue, cb => cb());\n    } // Dispose unused controllers.\n\n    each(disposed, ctrl => ctrl.dispose()); // Update existing controllers.\n\n    each(ctrls, (ctrl, i) => {\n      const values = springs[i];\n      setSprings(ctrl, values); // Update the default props.\n\n      ctrl.start({\n        default: context\n      }); // Apply updates created during render.\n\n      const update = updates[i];\n      if (update) {\n        // Start animating unless a ref exists.\n        if (refProp.current) {\n          ctrl.queue.push(update);\n        } else {\n          ctrl.start(update);\n        }\n      }\n    });\n  }); // Dispose all controllers on unmount.\n\n  useOnce(() => () => {\n    each(state.ctrls, ctrl => ctrl.dispose());\n  }); // Return a deep copy of the `springs` array so the caller can\n  // safely mutate it during render.\n\n  const values = springs.map(x => _extends({}, x));\n  return propsFn || arguments.length == 3 ? [values, api.start, api.stop] : values;\n}\n\n/**\n * The props that `useSpring` recognizes.\n */\n\n/** @internal */\nfunction useSpring(props, deps) {\n  const isFn = is.fun(props);\n  const [[values], update, stop] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);\n  return isFn || arguments.length == 2 ? [values, update, stop] : values;\n}\nfunction useTrail(length, propsArg, deps) {\n  const propsFn = is.fun(propsArg) && propsArg;\n  if (propsFn && !deps) deps = [];\n  const ctrls = [];\n  const result = useSprings(length, (i, ctrl) => {\n    ctrls[i] = ctrl;\n    return getProps(propsArg, i, ctrl);\n  },\n  // Ensure the props function is called when no deps exist.\n  // This works around the 3 argument rule.\n  deps || [{}]);\n  useLayoutEffect(() => {\n    const reverse = is.obj(propsArg) && propsArg.reverse;\n    for (let i = 0; i < ctrls.length; i++) {\n      const parent = ctrls[i + (reverse ? 1 : -1)];\n      if (parent) ctrls[i].update({\n        to: parent.springs\n      }).start();\n    }\n  }, deps);\n  if (propsFn || arguments.length == 3) {\n    const update = result[1];\n    result[1] = useCallbackOne(propsArg => {\n      const reverse = is.obj(propsArg) && propsArg.reverse;\n      return update((i, ctrl) => {\n        const props = getProps(propsArg, i, ctrl);\n        const parent = ctrls[i + (reverse ? 1 : -1)];\n        if (parent) props.to = parent.springs;\n        return props;\n      });\n    }, deps);\n    return result;\n  }\n  return result[0];\n}\n\n// TODO: convert to \"const enum\" once Babel supports it\n\n/** This transition is being mounted */\nconst MOUNT = 'mount';\n/** This transition is entering or has entered */\n\nconst ENTER = 'enter';\n/** This transition had its animations updated */\n\nconst UPDATE = 'update';\n/** This transition will expire after animating */\n\nconst LEAVE = 'leave';\nfunction useTransition(data, props, deps) {\n  const {\n    ref,\n    reset,\n    sort,\n    trail = 0,\n    expires = true\n  } = props; // Every item has its own transition.\n\n  const items = toArray(data);\n  const transitions = []; // Keys help with reusing transitions between renders.\n  // The `key` prop can be undefined (which means the items themselves are used\n  // as keys), or a function (which maps each item to its key), or an array of\n  // keys (which are assigned to each item by index).\n\n  const keys = getKeys(items, props); // The \"onRest\" callbacks need a ref to the latest transitions.\n\n  const usedTransitions = useRef(null);\n  const prevTransitions = reset ? null : usedTransitions.current;\n  useLayoutEffect(() => {\n    usedTransitions.current = transitions;\n  }); // Destroy all transitions on dismount.\n\n  useOnce(() => () => each(usedTransitions.current, t => {\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n    }\n    t.ctrl.dispose();\n  })); // Map old indices to new indices.\n\n  const reused = [];\n  if (prevTransitions) each(prevTransitions, (t, i) => {\n    // Expired transitions are not rendered.\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  }); // Mount new items with fresh transitions.\n\n  each(items, (item, i) => {\n    transitions[i] || (transitions[i] = {\n      key: keys[i],\n      item,\n      phase: MOUNT,\n      ctrl: new Controller()\n    });\n  }); // Update the item of any transition whose key still exists,\n  // and ensure leaving transitions are rendered until they finish.\n\n  if (reused.length) {\n    let i = -1;\n    each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions[prevIndex];\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = _extends(_extends({}, t), {}, {\n          item: items[keyIndex]\n        });\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n  if (is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item));\n  } // Track cumulative delay for the \"trail\" prop.\n\n  let delay = -trail; // Expired transitions use this to dismount.\n\n  const forceUpdate = useForceUpdate(); // These props are inherited by every phase change.\n\n  const defaultProps = getDefaultProps(props); // Generate changes to apply in useEffect.\n\n  const changes = new Map();\n  each(transitions, (t, i) => {\n    const key = t.key;\n    const prevPhase = t.phase;\n    let to;\n    let phase;\n    if (prevPhase == MOUNT) {\n      to = props.enter;\n      phase = ENTER;\n    } else {\n      const isLeave = keys.indexOf(key) < 0;\n      if (prevPhase != LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else return;\n    } // When \"to\" is a function, it can return (1) an array of \"useSpring\" props,\n    // (2) an async function, or (3) an object with any \"useSpring\" props.\n\n    to = callProp(to, t.item, i);\n    to = is.obj(to) ? inferTo(to) : {\n      to\n    };\n    if (!to.config) {\n      const config = props.config || defaultProps.config;\n      to.config = callProp(config, t.item, i);\n    } // The payload is used to update the spring props once the current render is committed.\n\n    const payload = _extends(_extends({}, defaultProps), {}, {\n      delay: delay += trail,\n      // This prevents implied resets.\n      reset: false\n    }, to);\n    if (phase == ENTER && is.und(payload.from)) {\n      // The `initial` prop is used on the first render of our parent component,\n      // as well as when `reset: true` is passed. It overrides the `from` prop\n      // when defined, and it makes `enter` instant when null.\n      const from = is.und(props.initial) || prevTransitions ? props.from : props.initial;\n      payload.from = callProp(from, t.item, i);\n    }\n    const {\n      onRest\n    } = payload;\n    payload.onRest = result => {\n      const transitions = usedTransitions.current;\n      const t = transitions.find(t => t.key === key);\n      if (!t) return;\n      if (is.fun(onRest)) {\n        onRest(result, t);\n      } // Reset the phase of a cancelled enter/leave transition, so it can\n      // retry the animation on the next render.\n\n      if (result.cancelled && t.phase != UPDATE) {\n        t.phase = prevPhase;\n        return;\n      }\n      if (t.ctrl.idle) {\n        const idle = transitions.every(t => t.ctrl.idle);\n        if (t.phase == LEAVE) {\n          const expiry = callProp(expires, t.item);\n          if (expiry !== false) {\n            const expiryMs = expiry === true ? 0 : expiry;\n            t.expired = true; // Force update once the expiration delay ends.\n\n            if (!idle && expiryMs > 0) {\n              // The maximum timeout is 2^31-1\n              if (expiryMs <= 0x7fffffff) t.expirationId = setTimeout(forceUpdate, expiryMs);\n              return;\n            }\n          }\n        } // Force update once idle and expired items exist.\n\n        if (idle && transitions.some(t => t.expired)) {\n          forceUpdate();\n        }\n      }\n    };\n    const springs = getSprings(t.ctrl, payload);\n    changes.set(t, {\n      phase,\n      springs,\n      payload\n    });\n  }); // The prop overrides from an ancestor.\n\n  const context = useSpringContext(); // Merge the context into each transition.\n\n  useLayoutEffect(() => {\n    each(transitions, t => {\n      t.ctrl.start({\n        default: context\n      });\n    });\n  }, [context]);\n  const api = useMemo$1(() => {\n    return SpringHandle.create(() => {\n      return usedTransitions.current.map(t => t.ctrl);\n    });\n  }, []);\n  useImperativeHandle(ref, () => api);\n  useLayoutEffect(() => {\n    each(changes, (_ref7, t) => {\n      let {\n        phase,\n        springs,\n        payload\n      } = _ref7;\n      setSprings(t.ctrl, springs);\n      if (!context.cancel) {\n        t.phase = phase;\n        if (phase == ENTER) {\n          t.ctrl.start({\n            default: context\n          });\n        }\n        t.ctrl[ref ? 'update' : 'start'](payload);\n      }\n    });\n  }, reset ? void 0 : deps);\n  const renderTransitions = render => /*#__PURE__*/createElement(Fragment, null, transitions.map((t, i) => {\n    const {\n      springs\n    } = changes.get(t) || t.ctrl;\n    const elem = render(_extends({}, springs), t.item, t, i);\n    return elem && elem.type ? /*#__PURE__*/createElement(elem.type, _extends({}, elem.props, {\n      key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,\n      ref: elem.ref\n    })) : elem;\n  }));\n  return arguments.length == 3 ? [renderTransitions, api.start, api.stop] : renderTransitions;\n}\nfunction getKeys(items, _ref8) {\n  let {\n    key,\n    keys = key\n  } = _ref8;\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);\n}\n\n/**\n * The `Spring` component passes `SpringValue` objects to your render prop.\n */\nfunction Spring(_ref) {\n  let {\n      children\n    } = _ref,\n    props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n  return children(useSpring(props));\n}\nfunction Trail(_ref) {\n  let {\n      items,\n      children\n    } = _ref,\n    props = _objectWithoutPropertiesLoose(_ref, [\"items\", \"children\"]);\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\nfunction Transition(_ref) {\n  let {\n      items,\n      children\n    } = _ref,\n    props = _objectWithoutPropertiesLoose(_ref, [\"items\", \"children\"]);\n  return /*#__PURE__*/createElement(Fragment, null, useTransition(items, props)(children));\n}\n\n/**\n * An `Interpolation` is a memoized value that's computed whenever one of its\n * `FluidValue` dependencies has its value changed.\n *\n * Other `FrameValue` objects can depend on this. For example, passing an\n * `Interpolation` as the `to` prop of a `useSpring` call will trigger an\n * animation toward the memoized value.\n */\n\nclass Interpolation extends FrameValue {\n  /** Useful for debugging. */\n\n  /** Equals false when in the frameloop */\n\n  /** The function that maps inputs values to output */\n  constructor(source, args) {\n    super();\n    this.source = source;\n    this.key = void 0;\n    this.idle = true;\n    this.calc = void 0;\n    this.calc = createInterpolator(...args);\n    const value = this._get();\n    const nodeType = is.arr(value) ? AnimatedArray : AnimatedValue; // Assume the computed value never changes type.\n\n    setAnimated(this, nodeType.create(value));\n  }\n  advance(_dt) {\n    const value = this._get();\n    const oldValue = this.get();\n    if (!isEqual(value, oldValue)) {\n      getAnimated(this).setValue(value);\n      this._onChange(value, this.idle);\n    }\n  }\n  _get() {\n    const inputs = is.arr(this.source) ? this.source.map(node => node.get()) : toArray(this.source.get());\n    return this.calc(...inputs);\n  }\n  _reset() {\n    each(getPayload(this), node => node.reset());\n    super._reset();\n  }\n  _start() {\n    this.idle = false;\n    super._start();\n    if (skipAnimation) {\n      this.idle = true;\n      this.advance();\n    } else {\n      frameLoop.start(this);\n    }\n  }\n  _attach() {\n    // Start observing our \"source\" once we have an observer.\n    let idle = true;\n    let priority = 1;\n    each(toArray(this.source), source => {\n      if (isFrameValue(source)) {\n        if (!source.idle) idle = false;\n        priority = Math.max(priority, source.priority + 1);\n      }\n      source.addChild(this);\n    });\n    this.priority = priority;\n    if (!idle) {\n      this._reset();\n      this._start();\n    }\n  }\n  _detach() {\n    // Stop observing our \"source\" once we have no observers.\n    each(toArray(this.source), source => {\n      source.removeChild(this);\n    }); // This removes us from the frameloop.\n\n    this.idle = true;\n  }\n  /** @internal */\n\n  onParentChange(event) {\n    // Ensure our start value respects our parent values, in case\n    // any of their animations were restarted with the \"reset\" prop.\n    if (event.type == 'start') {\n      this.advance();\n    } // Change events are useful for (1) reacting to non-animated parents\n    // and (2) reacting to the last change in a parent animation.\n    else if (event.type == 'change') {\n      // If we're idle, we know for sure that this change is *not*\n      // caused by an animation.\n      if (this.idle) {\n        this.advance();\n      } // Leave the frameloop when all parents are done animating.\n      else if (event.idle) {\n        this.idle = toArray(this.source).every(source => source.idle !== false);\n        if (this.idle) {\n          this.advance();\n          each(getPayload(this), node => {\n            node.done = true;\n          });\n        }\n      }\n    } // Ensure our priority is greater than all parents, which means\n    // our value won't be updated until our parents have updated.\n    else if (event.type == 'priority') {\n      this.priority = toArray(this.source).reduce((max, source) => Math.max(max, (source.priority || 0) + 1), 0);\n    }\n    super.onParentChange(event);\n  }\n}\n\n/** Map the value of one or more dependencies */\n\nconst to = function (source) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n  return new Interpolation(source, args);\n};\n/** @deprecated Use the `to` export instead */\n\nconst interpolate = function (source) {\n  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n  return deprecateInterpolate(), new Interpolation(source, args);\n};\n/** Extract the raw value types that are being interpolated */\n\nGlobals.assign({\n  createStringInterpolator: createStringInterpolator$1,\n  to: (source, args) => new Interpolation(source, args)\n});\n/** Advance all animations forward one frame */\n\nconst update = () => Globals.frameLoop.advance();\nexport { BailSignal, Controller, FrameValue, Interpolation, Spring, SpringContext, SpringHandle, SpringValue, Trail, Transition, config, inferTo, interpolate, to, update, useChain, useSpring, useSprings, useTrail, useTransition };","map":{"version":3,"mappings":"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","names":["useChain","refs","timeSteps","timeFrame","useLayoutEffect","prevDelay","each","ref","i","current","controllers","length","delay","isNaN","ctrl","queue","props","start","p","Promise","resolve","updates","map","q","then","push","config","default","tension","friction","gentle","wobbly","stiff","slow","molasses","linear","t","defaults","configs","mass","damping","easing","clamp","AnimationConfig","constructor","frequency","velocity","restVelocity","precision","progress","duration","bounce","decay","round","Object","assign","mergeConfig","newConfig","defaultConfig","sanitizeConfig","key","is","und","Math","pow","PI","undefined","isTensionConfig","emptyArray","Animation","changed","values","toValues","fromValues","to","from","immediate","onStart","onChange","onRest","useMemo","create","deps","useMemoOne","callProp","value","args","fun","matchProp","toArray","includes","getProps","arg","arr","hasDefaultProp","getDefaultProp","getDefaultProps","omitKeys","keys","DEFAULT_PROPS","mergeDefaultProps","RESERVED_PROPS","loop","reset","pause","cancel","reverse","onDelayEnd","onProps","items","trail","sort","expires","initial","enter","update","leave","children","callId","parentId","getForwardProps","forward","count","prop","inferTo","out","val","computeGoal","getFluidConfig","get","isAnimatedString","G","range","output","scheduleProps","state","actions","reject","timeout","resumeQueue","add","onResume","resume","onPause","time","now","pauseQueue","frameLoop","setTimeout","delete","cancelId","err","getCombinedResult","target","results","some","result","cancelled","getCancelledResult","every","noop","getNoopResult","getFinishedResult","finished","runAsync","asyncTo","prevTo","promise","prevPromise","asyncId","defaultProps","preventBail","bail","bailPromise","withBailHandler","fn","onError","BailSignal","catch","bailIfEnded","bailSignal","bailResult","animate","arg1","arg2","obj","animating","stop","bind","all","cancelAsync","Error","isFrameValue","FrameValue","nextId","FluidValue","id","_priority","_children","Set","priority","_onPriorityChange","node","getAnimated","getValue","interpolate","deprecateInterpolate","addChild","child","size","_attach","removeChild","_detach","onParentChange","type","idle","_reset","_start","_emit","parent","_onChange","event","Array","CREATED","IDLE","ACTIVE","PAUSED","DISPOSED","SpringValue","animation","_phase","_state","_defaultProps","_lastCallId","_lastToId","goal","getFluidValue","AnimatedValue","lastVelocity","getPayload","advance","dt","anim","payload","toConfig","forEach","done","lastPosition","position","elapsed","elapsedTime","v0","min","e","exp","abs","bounceFactor","canBounce","isGrowing","isMoving","isBouncing","step","numSteps","ceil","n","springForce","dampingForce","acceleration","Number","console","warn","setValue","finish","phase","set","_focus","_set","_stop","checkDisposed","flush","_update","dispose","_prepareNode","_updateNode","nodeType","_getNodeType","setAnimated","parentNode","AnimatedArray","AnimatedString","isLoop","mergeDefaultProp","_merge","nextProps","createLoopUpdate","hasToProp","hasFromProp","coerceEventProp","prevFrom","hasFromChanged","isEqual","hasToChanged","fromConfig","hasAsyncTo","isAnimatable","num","name","goalType","started","hasValueChanged","onRestQueue","checkFinishedOnRest","onRestIndex","oldValue","spring","loopRet","overrides","createUpdate","findDefined","declareUpdate","BATCHED_EVENTS","Controller","springs","_flush","_initialProps","_lastAsyncId","_active","_events","Map","_onFrame","prepareKeys","flushUpdateQueue","iterator","isActive","onFrame","flushUpdate","handler","promises","getSprings","prepareSprings","createSpring","setSprings","observer","ctx","React","SpringContext","_ref","inherited","useContext","Provider","React.createElement","Consumer","useSpringContext","SpringHandle","getControllers","useSprings","propsFn","layoutId","useRef","forceUpdate","useForceUpdate","useState","ctrls","canFlushSync","refProp","prevLength","usePrev","disposed","slice","declareUpdates","startIndex","endIndex","api","context","cb","useOnce","x","arguments","useSpring","isFn","useTrail","propsArg","useCallbackOne","MOUNT","ENTER","UPDATE","LEAVE","useTransition","data","transitions","getKeys","usedTransitions","prevTransitions","expired","clearTimeout","expirationId","reused","indexOf","item","keyIndex","prevIndex","splice","a","b","changes","prevPhase","isLeave","find","expiry","expiryMs","useImperativeHandle","renderTransitions","render","elem","str","Spring","Trail","trails","index","Transition","Interpolation","source","calc","createInterpolator","_get","_dt","inputs","max","reduce","Globals","createStringInterpolator"],"sources":["/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/hooks/useChain.js","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/constants.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/AnimationConfig.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/Animation.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/helpers.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/scheduleProps.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/AnimationResult.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/runAsync.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/FrameValue.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/SpringPhase.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/SpringValue.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/Controller.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/SpringContext.tsx","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/SpringHandle.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/hooks/useSprings.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/hooks/useSpring.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/hooks/useTrail.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/TransitionPhase.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/hooks/useTransition.tsx","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/components/Spring.tsx","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/components/Trail.tsx","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/components/Transition.tsx","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/Interpolation.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/interpolate.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/core/src/globals.ts"],"sourcesContent":["import { useLayoutEffect } from 'react-layout-effect'\nimport { each } from '@react-spring/shared'\n\n/** API\n *  useChain(references, timeSteps, timeFrame)\n */\n\nexport function useChain(refs, timeSteps, timeFrame = 1000) {\n  useLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0\n      each(refs, (ref, i) => {\n        if (!ref.current) return\n\n        const { controllers } = ref.current\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i]\n\n          // Use the previous delay if none exists.\n          if (isNaN(delay)) delay = prevDelay\n          else prevDelay = delay\n\n          each(controllers, ctrl => {\n            each(ctrl.queue, props => {\n              props.delay = delay + (props.delay || 0)\n            })\n            ctrl.start()\n          })\n        }\n      })\n    } else {\n      let p = Promise.resolve()\n      each(refs, ref => {\n        const { controllers, start } = ref.current || {}\n        if (controllers && controllers.length) {\n          // Take the queue of each controller\n          const updates = controllers.map(ctrl => {\n            const q = ctrl.queue\n            ctrl.queue = []\n            return q\n          })\n\n          // Apply the queue when the previous ref stops animating\n          p = p.then(() => {\n            each(controllers, (ctrl, i) => ctrl.queue.push(...updates[i]))\n            return start()\n          })\n        }\n      })\n    }\n  })\n}\n","// The `mass` prop defaults to 1\nexport const config = {\n  default: { tension: 170, friction: 26 },\n  gentle: { tension: 120, friction: 14 },\n  wobbly: { tension: 180, friction: 12 },\n  stiff: { tension: 210, friction: 20 },\n  slow: { tension: 280, friction: 60 },\n  molasses: { tension: 280, friction: 120 },\n} as const\n","import { is } from '@react-spring/shared'\nimport { config as configs } from './constants'\n\nconst linear = (t: number) => t\nconst defaults: any = {\n  ...configs.default,\n  mass: 1,\n  damping: 1,\n  easing: linear,\n  clamp: false,\n}\n\nexport class AnimationConfig {\n  /**\n   * With higher tension, the spring will resist bouncing and try harder to stop at its end value.\n   *\n   * When tension is zero, no animation occurs.\n   */\n  tension!: number\n\n  /**\n   * The damping ratio coefficient, or just the damping ratio when `speed` is defined.\n   *\n   * When `speed` is defined, this value should be between 0 and 1.\n   *\n   * Higher friction means the spring will slow down faster.\n   */\n  friction!: number\n\n  /**\n   * The natural frequency (in seconds), which dictates the number of bounces\n   * per second when no damping exists.\n   *\n   * When defined, `tension` is derived from this, and `friction` is derived\n   * from `tension` and `damping`.\n   */\n  frequency?: number\n\n  /**\n   * The damping ratio, which dictates how the spring slows down.\n   *\n   * Set to `0` to never slow down. Set to `1` to slow down without bouncing.\n   * Between `0` and `1` is for you to explore.\n   *\n   * Only works when `frequency` is defined.\n   *\n   * Defaults to 1\n   */\n  damping!: number\n\n  /**\n   * Higher mass means more friction is required to slow down.\n   *\n   * Defaults to 1, which works fine most of the time.\n   */\n  mass!: number\n\n  /**\n   * The initial velocity of one or more values.\n   */\n  velocity: number | number[] = 0\n\n  /**\n   * The smallest velocity before the animation is considered \"not moving\".\n   *\n   * When undefined, `precision` is used instead.\n   */\n  restVelocity?: number\n\n  /**\n   * The smallest distance from a value before that distance is essentially zero.\n   *\n   * This helps in deciding when a spring is \"at rest\". The spring must be within\n   * this distance from its final value, and its velocity must be lower than this\n   * value too (unless `restVelocity` is defined).\n   */\n  precision?: number\n\n  /**\n   * For `duration` animations only. Note: The `duration` is not affected\n   * by this property.\n   *\n   * Defaults to `0`, which means \"start from the beginning\".\n   *\n   * Setting to `1+` makes an immediate animation.\n   *\n   * Setting to `0.5` means \"start from the middle of the easing function\".\n   *\n   * Any number `>= 0` and `<= 1` makes sense here.\n   */\n  progress?: number\n\n  /**\n   * Animation length in number of milliseconds.\n   */\n  duration?: number\n\n  /**\n   * The animation curve. Only used when `duration` is defined.\n   *\n   * Defaults to quadratic ease-in-out.\n   */\n  easing!: (t: number) => number\n\n  /**\n   * Avoid overshooting by ending abruptly at the goal value.\n   */\n  clamp!: boolean\n\n  /**\n   * When above zero, the spring will bounce instead of overshooting when\n   * exceeding its goal value. Its velocity is multiplied by `-1 + bounce`\n   * whenever its current value equals or exceeds its goal. For example,\n   * setting `bounce` to `0.5` chops the velocity in half on each bounce,\n   * in addition to any friction.\n   */\n  bounce?: number\n\n  /**\n   * \"Decay animations\" decelerate without an explicit goal value.\n   * Useful for scrolling animations.\n   *\n   * Use `true` for the default exponential decay factor (`0.998`).\n   *\n   * When a `number` between `0` and `1` is given, a lower number makes the\n   * animation slow down faster. And setting to `1` would make an unending\n   * animation.\n   */\n  decay?: boolean | number\n\n  /**\n   * While animating, round to the nearest multiple of this number.\n   * The `from` and `to` values are never rounded, as well as any value\n   * passed to the `set` method of an animated value.\n   */\n  round?: number\n\n  constructor() {\n    Object.assign(this, defaults)\n  }\n}\n\nexport function mergeConfig(\n  config: AnimationConfig,\n  newConfig: Partial<AnimationConfig>,\n  defaultConfig?: Partial<AnimationConfig>\n): typeof config\n\nexport function mergeConfig(\n  config: any,\n  newConfig: object,\n  defaultConfig?: object\n) {\n  if (defaultConfig) {\n    defaultConfig = { ...defaultConfig }\n    sanitizeConfig(defaultConfig, newConfig)\n    newConfig = { ...defaultConfig, ...newConfig }\n  }\n\n  sanitizeConfig(config, newConfig)\n  Object.assign(config, newConfig)\n\n  for (const key in defaults) {\n    if (config[key] == null) {\n      config[key] = defaults[key]\n    }\n  }\n\n  let { mass, frequency, damping } = config\n  if (!is.und(frequency)) {\n    if (frequency < 0.01) frequency = 0.01\n    if (damping < 0) damping = 0\n    config.tension = Math.pow((2 * Math.PI) / frequency, 2) * mass\n    config.friction = (4 * Math.PI * damping * mass) / frequency\n  }\n\n  return config\n}\n\n// Prevent a config from accidentally overriding new props.\n// This depends on which \"config\" props take precedence when defined.\nfunction sanitizeConfig(\n  config: Partial<AnimationConfig>,\n  props: Partial<AnimationConfig>\n) {\n  if (!is.und(props.decay)) {\n    config.duration = undefined\n  } else {\n    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction)\n    if (\n      isTensionConfig ||\n      !is.und(props.frequency) ||\n      !is.und(props.damping) ||\n      !is.und(props.mass)\n    ) {\n      config.duration = undefined\n      config.decay = undefined\n    }\n    if (isTensionConfig) {\n      config.frequency = undefined\n    }\n  }\n}\n","import { AnimatedValue } from '@react-spring/animated'\nimport { FluidValue } from '@react-spring/shared'\nimport { AnimationConfig } from './AnimationConfig'\nimport { OnStart, OnChange } from './types'\n\nconst emptyArray: readonly any[] = []\n\n/** @internal */\ntype OnRest = (cancel?: boolean) => void\n\n/** An animation being executed by the frameloop */\nexport class Animation<T = any> {\n  changed = false\n  values: readonly AnimatedValue[] = emptyArray\n  toValues: readonly number[] | null = null\n  fromValues: readonly number[] = emptyArray\n\n  to!: T | FluidValue<T>\n  from!: T | FluidValue<T>\n  config = new AnimationConfig()\n  immediate = false\n  onStart?: OnStart<T>\n  onChange?: OnChange<T>\n  onRest: OnRest[] = []\n}\n","import { useMemoOne } from 'use-memo-one'\nimport {\n  is,\n  each,\n  toArray,\n  getFluidConfig,\n  isAnimatedString,\n  AnyFn,\n  OneOrMore,\n  FluidValue,\n  Lookup,\n  Falsy,\n} from '@react-spring/shared'\nimport * as G from '@react-spring/shared/globals'\nimport { ReservedProps, ForwardProps, InferTo } from './types'\n\n// @see https://github.com/alexreardon/use-memo-one/pull/10\nexport const useMemo: typeof useMemoOne = (create, deps) =>\n  useMemoOne(create, deps || [{}])\n\nexport function callProp<T>(\n  value: T,\n  ...args: T extends AnyFn ? Parameters<T> : unknown[]\n): T extends AnyFn<any, infer U> ? U : T {\n  return is.fun(value) ? value(...args) : value\n}\n\n/** Try to coerce the given value into a boolean using the given key */\nexport const matchProp = (\n  value: boolean | OneOrMore<string> | ((key: any) => boolean) | undefined,\n  key: string | undefined\n) =>\n  value === true ||\n  !!(\n    key &&\n    value &&\n    (is.fun(value) ? value(key) : toArray(value).includes(key))\n  )\n\nexport const concatFn = <T extends AnyFn>(first: T | undefined, last: T) =>\n  first ? (...args: Parameters<T>) => (first(...args), last(...args)) : last\n\ntype AnyProps<T, Arg = never> = OneOrMore<T> | ((i: number, arg: Arg) => T)\n\nexport const getProps = <T, Arg = never>(\n  props: AnyProps<T, Arg> | null | undefined,\n  i: number,\n  arg: Arg\n) =>\n  props &&\n  (is.fun(props) ? props(i, arg) : is.arr(props) ? props[i] : { ...props })\n\n/** Returns `true` if the given prop is having its default value set. */\nexport const hasDefaultProp = <T extends Lookup>(props: T, key: keyof T) =>\n  !is.und(getDefaultProp(props, key))\n\n/** Get the default value being set for the given `key` */\nexport const getDefaultProp = <T extends Lookup>(props: T, key: keyof T) =>\n  props.default === true\n    ? props[key]\n    : props.default\n    ? props.default[key]\n    : undefined\n\n/**\n * Extract the default props from an update.\n *\n * When the `default` prop is falsy, this function still behaves as if\n * `default: true` was used. The `default` prop is always respected when\n * truthy.\n */\nexport const getDefaultProps = <T extends Lookup>(\n  props: Lookup,\n  omitKeys: (string | Falsy)[] = [],\n  defaults: Lookup = {} as any\n) => {\n  let keys: readonly string[] = DEFAULT_PROPS\n  if (props.default && props.default !== true) {\n    props = props.default\n    keys = Object.keys(props)\n  }\n  for (const key of keys) {\n    const value = props[key]\n    if (!is.und(value) && !omitKeys.includes(key)) {\n      defaults[key] = value\n    }\n  }\n  return defaults as T\n}\n\n/** Merge the default props of an update into a props cache. */\nexport const mergeDefaultProps = (\n  defaults: Lookup,\n  props: Lookup,\n  omitKeys?: (string | Falsy)[]\n) => getDefaultProps(props, omitKeys, defaults)\n\n/** These props can have default values */\nexport const DEFAULT_PROPS = [\n  'pause',\n  'cancel',\n  'config',\n  'immediate',\n  'onDelayEnd',\n  'onProps',\n  'onStart',\n  'onChange',\n  'onRest',\n] as const\n\nconst RESERVED_PROPS: Required<ReservedProps> = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  onDelayEnd: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onRest: 1,\n\n  // Transition props\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n\n  // Internal props\n  keys: 1,\n  callId: 1,\n  parentId: 1,\n}\n\n/**\n * Extract any properties whose keys are *not* reserved for customizing your\n * animations. All hooks use this function, which means `useTransition` props\n * are reserved for `useSpring` calls, etc.\n */\nfunction getForwardProps<Props extends ReservedProps>(\n  props: Props\n): ForwardProps<Props> | undefined {\n  const forward: any = {}\n\n  let count = 0\n  each(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value\n      count++\n    }\n  })\n\n  if (count) {\n    return forward\n  }\n}\n\n/**\n * Clone the given `props` and move all non-reserved props\n * into the `to` prop.\n */\nexport function inferTo<T extends object>(props: T): InferTo<T> {\n  const to = getForwardProps(props)\n  if (to) {\n    const out: any = { to }\n    each(props, (val, key) => key in to || (out[key] = val))\n    return out\n  }\n  return { ...props } as any\n}\n\n// Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\nexport function computeGoal<T>(value: T | FluidValue<T>): T {\n  const config = getFluidConfig(value)\n  return config\n    ? computeGoal(config.get())\n    : is.arr(value)\n    ? value.map(computeGoal)\n    : isAnimatedString(value)\n    ? (G.createStringInterpolator({\n        range: [0, 1],\n        output: [value, value] as any,\n      })(1) as any)\n    : value\n}\n","import { matchProp, callProp } from './helpers'\nimport { RunAsyncState, RunAsyncProps } from './runAsync'\nimport { SpringProps, AnimationResolver } from './types'\nimport { AsyncResult } from './AnimationResult'\nimport { Timeout, Globals as G } from '@react-spring/shared'\n\ninterface ScheduledProps<T> {\n  key?: string\n  props: Pick<SpringProps<T>, 'cancel' | 'pause' | 'delay'>\n  state: RunAsyncState<T>\n  actions: {\n    pause: () => void\n    resume: () => void\n    start: (props: RunAsyncProps<T>, resolve: AnimationResolver<T>) => void\n  }\n}\n\n/**\n * This function sets a timeout if both the `delay` prop exists and\n * the `cancel` prop is not `true`.\n *\n * The `actions.start` function must handle the `cancel` prop itself,\n * but the `pause` prop is taken care of.\n */\nexport function scheduleProps<T>(\n  callId: number,\n  { key, props, state, actions }: ScheduledProps<T>\n): AsyncResult<T> {\n  return new Promise((resolve, reject) => {\n    let delay: number\n    let timeout: Timeout\n\n    let pause = false\n    let cancel = matchProp(props.cancel, key)\n\n    if (cancel) {\n      onStart()\n    } else {\n      delay = callProp(props.delay || 0, key)\n      pause = matchProp(props.pause, key)\n      if (pause) {\n        state.resumeQueue.add(onResume)\n        actions.pause()\n      } else {\n        actions.resume()\n        onResume()\n      }\n    }\n\n    function onPause() {\n      state.resumeQueue.add(onResume)\n      timeout.cancel()\n      // Cache the remaining delay.\n      delay = timeout.time - G.now()\n    }\n\n    function onResume() {\n      if (delay > 0) {\n        state.pauseQueue.add(onPause)\n        timeout = G.frameLoop.setTimeout(onStart, delay)\n      } else {\n        onStart()\n      }\n    }\n\n    function onStart() {\n      state.pauseQueue.delete(onPause)\n\n      // Maybe cancelled during its delay.\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true\n      }\n\n      try {\n        actions.start({ ...props, callId, delay, cancel, pause }, resolve)\n      } catch (err) {\n        reject(err)\n      }\n    }\n  })\n}\n","import { SpringPhase } from './SpringPhase'\nimport { SpringStopFn } from './types'\n\n/** @internal */\nexport interface AnimationTarget<T> {\n  get(): T\n  is(phase: SpringPhase): boolean\n  start(props: any): AsyncResult<T>\n  stop: SpringStopFn<any>\n}\n\n/** The object given to the `onRest` prop and `start` promise. */\nexport interface AnimationResult<T = any> {\n  value: T\n  target?: AnimationTarget<T>\n  /** When true, no animation ever started. */\n  noop?: boolean\n  /** When true, the animation was neither cancelled nor stopped prematurely. */\n  finished?: boolean\n  /** When true, the animation was cancelled before it could finish. */\n  cancelled?: boolean\n}\n\n/** The promised result of an animation. */\nexport type AsyncResult<T = any> = Promise<AnimationResult<T>>\n\n/** @internal */\nexport const getCombinedResult = <T>(\n  target: AnimationTarget<T>,\n  results: AnimationResult<T>[]\n): AnimationResult<T> =>\n  results.length == 1\n    ? results[0]\n    : results.some(result => result.cancelled)\n    ? getCancelledResult(target)\n    : results.every(result => result.noop)\n    ? getNoopResult(target)\n    : getFinishedResult(\n        target,\n        results.every(result => result.finished)\n      )\n\n/** No-op results are for updates that never start an animation. */\nexport const getNoopResult = <T>(\n  target: AnimationTarget<T>,\n  value = target.get()\n) => ({\n  value,\n  noop: true,\n  finished: true,\n  target,\n})\n\nexport const getFinishedResult = <T>(\n  target: AnimationTarget<T>,\n  finished: boolean,\n  value = target.get()\n) => ({\n  value,\n  finished,\n  target,\n})\n\nexport const getCancelledResult = <T>(\n  target: AnimationTarget<T>,\n  value = target.get()\n) => ({\n  value,\n  cancelled: true,\n  target,\n})\n","import { is, each } from '@react-spring/shared'\nimport * as G from '@react-spring/shared/globals'\n\nimport { getDefaultProps } from './helpers'\nimport {\n  SpringChain,\n  SpringDefaultProps,\n  SpringProps,\n  SpringToFn,\n} from './types'\nimport {\n  getCancelledResult,\n  getFinishedResult,\n  AnimationResult,\n  AsyncResult,\n  AnimationTarget,\n} from './AnimationResult'\n\nexport interface RunAsyncProps<T = any> extends SpringProps<T> {\n  callId: number\n  parentId?: number\n  cancel: boolean\n  pause: boolean\n  delay: number\n  to?: any\n}\n\nexport interface RunAsyncState<T> {\n  pauseQueue: Set<Function>\n  resumeQueue: Set<Function>\n  asyncId?: number\n  asyncTo?: SpringChain<T> | SpringToFn<T>\n  promise?: AsyncResult<T>\n  cancelId?: number\n}\n\n/**\n * Start an async chain or an async script.\n *\n * Always call `runAsync` in the action callback of a `scheduleProps` call.\n *\n * The `T` parameter can be a set of animated values (as an object type)\n * or a primitive type for a single animated value.\n */\nexport async function runAsync<T>(\n  to: SpringChain<T> | SpringToFn<T>,\n  props: RunAsyncProps<T>,\n  state: RunAsyncState<T>,\n  target: AnimationTarget<T>\n): AsyncResult<T> {\n  if (props.pause) {\n    await new Promise(resume => {\n      state.resumeQueue.add(resume)\n    })\n  }\n\n  const { callId, parentId, onRest } = props\n  const { asyncTo: prevTo, promise: prevPromise } = state\n\n  if (!parentId && to === prevTo && !props.reset) {\n    return prevPromise!\n  }\n\n  return (state.promise = (async (): AsyncResult<T> => {\n    state.asyncId = callId\n    state.asyncTo = to\n\n    // The default props of any `animate` calls.\n    const defaultProps = getDefaultProps<SpringDefaultProps<T>>(props, [\n      // The `onRest` prop is only called when the `runAsync` promise is resolved.\n      'onRest',\n    ])\n\n    let preventBail!: () => void\n    let bail: (error: any) => void\n\n    // This promise is rejected when the animation is interrupted.\n    const bailPromise = new Promise<void>(\n      (resolve, reject) => ((preventBail = resolve), (bail = reject))\n    )\n\n    // Stop animating when an error is caught.\n    const withBailHandler = <Args extends any[]>(\n      fn: (...args: Args) => AsyncResult<T>\n    ) => (...args: Args) => {\n      const onError = (err: any) => {\n        if (err instanceof BailSignal) {\n          bail(err) // Stop animating.\n        }\n        throw err\n      }\n      try {\n        return fn(...args).catch(onError)\n      } catch (err) {\n        onError(err)\n      }\n    }\n\n    const bailIfEnded = (bailSignal: BailSignal<T>) => {\n      const bailResult =\n        // The `cancel` prop or `stop` method was used.\n        (callId <= (state.cancelId || 0) && getCancelledResult(target)) ||\n        // The async `to` prop was replaced.\n        (callId !== state.asyncId && getFinishedResult(target, false))\n\n      if (bailResult) {\n        bailSignal.result = bailResult\n        throw bailSignal\n      }\n    }\n\n    // Note: This function cannot use the `async` keyword, because we want the\n    // `throw` statements to interrupt the caller.\n    const animate: any = withBailHandler((arg1: any, arg2?: any) => {\n      const bailSignal = new BailSignal()\n      bailIfEnded(bailSignal)\n\n      const props: any = is.obj(arg1) ? { ...arg1 } : { ...arg2, to: arg1 }\n      props.parentId = callId\n\n      each(defaultProps, (value, key) => {\n        if (is.und(props[key])) {\n          props[key] = value as any\n        }\n      })\n\n      return target.start(props).then(async result => {\n        bailIfEnded(bailSignal)\n\n        if (target.is('PAUSED')) {\n          await new Promise(resume => {\n            state.resumeQueue.add(resume)\n          })\n        }\n\n        return result\n      })\n    })\n\n    let result!: AnimationResult<T>\n    try {\n      let animating!: Promise<void>\n\n      // Async sequence\n      if (is.arr(to)) {\n        animating = (async (queue: any[]) => {\n          for (const props of queue) {\n            await animate(props)\n          }\n        })(to)\n      }\n\n      // Async script\n      else if (is.fun(to)) {\n        animating = Promise.resolve(\n          to(animate, target.stop.bind(target) as any)\n        )\n      }\n\n      await Promise.all([animating.then(preventBail), bailPromise])\n      result = getFinishedResult(target, true)\n\n      // Bail handling\n    } catch (err) {\n      if (err instanceof BailSignal) {\n        result = err.result\n      } else {\n        throw err\n      }\n\n      // Reset the async state.\n    } finally {\n      if (callId == state.asyncId) {\n        state.asyncId = parentId\n        state.asyncTo = parentId ? prevTo : undefined\n        state.promise = parentId ? prevPromise : undefined\n      }\n    }\n\n    if (is.fun(onRest)) {\n      G.batchedUpdates(() => {\n        onRest(result)\n      })\n    }\n\n    return result\n  })())\n}\n\nexport function cancelAsync(state: RunAsyncState<any>, callId: number) {\n  state.cancelId = callId\n  state.asyncId = state.asyncTo = state.promise = undefined\n}\n\n/** This error is thrown to signal an interrupted async animation. */\nexport class BailSignal<T = any> extends Error {\n  result!: AnimationResult<T>\n  constructor() {\n    super(\n      'An async animation has been interrupted. You see this error because you ' +\n        'forgot to use `await` or `.catch(...)` on its returned promise.'\n    )\n  }\n}\n","import { each, InterpolatorArgs, FluidValue, FluidObserver } from '@react-spring/shared'\nimport { getAnimated } from '@react-spring/animated'\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations'\nimport * as G from '@react-spring/shared/globals'\n\nimport { Interpolation } from './Interpolation'\n\nexport const isFrameValue = (value: any): value is FrameValue =>\n  value instanceof FrameValue\n\nlet nextId = 1\n\n/**\n * A kind of `FluidValue` that manages an `AnimatedValue` node.\n *\n * Its underlying value can be accessed and even observed.\n */\nexport abstract class FrameValue<T = any>\n  extends FluidValue<T, FrameValue.Event<T>>\n  implements FluidObserver<FrameValue.Event> {\n  readonly id = nextId++\n\n  abstract key?: string\n  abstract get idle(): boolean\n\n  protected _priority = 0\n  protected _children = new Set<FrameValue.Observer<T>>()\n\n  get priority() {\n    return this._priority\n  }\n  set priority(priority: number) {\n    if (this._priority != priority) {\n      this._priority = priority\n      this._onPriorityChange(priority)\n    }\n  }\n\n  /** Get the current value */\n  get(): T {\n    const node = getAnimated(this)\n    return node && node.getValue()\n  }\n\n  /** Create a spring that maps our value to another value */\n  to<Out>(...args: InterpolatorArgs<T, Out>) {\n    return G.to(this, args) as Interpolation<T, Out>\n  }\n\n  /** @deprecated Use the `to` method instead. */\n  interpolate<Out>(...args: InterpolatorArgs<T, Out>) {\n    deprecateInterpolate()\n    return G.to(this, args) as Interpolation<T, Out>\n  }\n\n  /** @internal */\n  abstract advance(dt: number): void\n\n  /** @internal */\n  addChild(child: FrameValue.Observer<T>): void {\n    if (!this._children.size) this._attach()\n    this._children.add(child)\n  }\n\n  /** @internal */\n  removeChild(child: FrameValue.Observer<T>): void {\n    this._children.delete(child)\n    if (!this._children.size) this._detach()\n  }\n\n  /** @internal */\n  onParentChange({ type }: FrameValue.Event) {\n    if (this.idle) {\n      // Start animating when a parent does.\n      if (type == 'start') {\n        this._reset()\n        this._start()\n      }\n    }\n    // Reset our animation state when a parent does, but only when\n    // our animation is active.\n    else if (type == 'reset') {\n      this._reset()\n    }\n  }\n\n  /** Called when the first child is added. */\n  protected _attach() {}\n\n  /** Called when the last child is removed. */\n  protected _detach() {}\n\n  /**\n   * Reset our animation state (eg: start values, velocity, etc)\n   * and tell our children to do the same.\n   *\n   * This is called when our goal value is changed during (or before)\n   * an animation.\n   */\n  protected _reset() {\n    this._emit({\n      type: 'reset',\n      parent: this,\n    })\n  }\n\n  /**\n   * Start animating if possible.\n   *\n   * Note: Be sure to call `_reset` first, or the animation will break.\n   * This method would like to call `_reset` for you, but that would\n   * interfere with paused animations.\n   */\n  protected _start() {\n    this._emit({\n      type: 'start',\n      parent: this,\n    })\n  }\n\n  /** Tell our children about our new value */\n  protected _onChange(value: T, idle = false) {\n    this._emit({\n      type: 'change',\n      parent: this,\n      value,\n      idle,\n    })\n  }\n\n  /** Tell our children about our new priority */\n  protected _onPriorityChange(priority: number) {\n    if (!this.idle) {\n      // Make the frameloop aware of our new priority.\n      G.frameLoop.start(this)\n    }\n    this._emit({\n      type: 'priority',\n      parent: this,\n      priority,\n    })\n  }\n\n  protected _emit(event: FrameValue.Event) {\n    // Clone \"_children\" so it can be safely mutated inside the loop.\n    each(Array.from(this._children), child => {\n      child.onParentChange(event)\n    })\n  }\n}\n\nexport declare namespace FrameValue {\n  /** A parent changed its value */\n  interface ChangeEvent<T = any> {\n    type: 'change'\n    value: T\n    idle: boolean\n  }\n\n  /** A parent changed its priority */\n  interface PriorityEvent {\n    type: 'priority'\n    priority: number\n  }\n\n  /** A parent reset the internal state of its current animation */\n  interface ResetEvent {\n    type: 'reset'\n  }\n\n  /** A parent entered the frameloop */\n  interface StartEvent {\n    type: 'start'\n  }\n\n  /** Events sent to children of `FrameValue` objects */\n  export type Event<T = any> = { parent: FrameValue<T> } & (\n    | ChangeEvent<T>\n    | PriorityEvent\n    | ResetEvent\n    | StartEvent\n  )\n\n  /** An object that handles `FrameValue` events */\n  export type Observer<T = any> = FluidObserver<Event<T>>\n}\n","// TODO: use \"const enum\" when Babel supports it\nexport type SpringPhase =\n  | typeof DISPOSED\n  | typeof CREATED\n  | typeof IDLE\n  | typeof PAUSED\n  | typeof ACTIVE\n\n/** The spring has not animated yet */\nexport const CREATED = 'CREATED'\n\n/** The spring has animated before */\nexport const IDLE = 'IDLE'\n\n/** The spring is animating */\nexport const ACTIVE = 'ACTIVE'\n\n/** The spring is frozen in time */\nexport const PAUSED = 'PAUSED'\n\n/** The spring cannot be animated */\nexport const DISPOSED = 'DISPOSED'\n","import {\n  is,\n  each,\n  noop,\n  flush,\n  isEqual,\n  toArray,\n  FluidValue,\n  getFluidConfig,\n  getFluidValue,\n  isAnimatedString,\n  Animatable,\n} from '@react-spring/shared'\nimport {\n  AnimatedType,\n  AnimatedValue,\n  AnimatedString,\n  AnimatedArray,\n  getPayload,\n  getAnimated,\n  setAnimated,\n  Animated,\n} from '@react-spring/animated'\nimport * as G from '@react-spring/shared/globals'\n\nimport { Animation } from './Animation'\nimport { mergeConfig } from './AnimationConfig'\nimport { scheduleProps } from './scheduleProps'\nimport { runAsync, RunAsyncState, RunAsyncProps, cancelAsync } from './runAsync'\nimport {\n  callProp,\n  computeGoal,\n  matchProp,\n  inferTo,\n  mergeDefaultProps,\n  getDefaultProps,\n  getDefaultProp,\n} from './helpers'\nimport { FrameValue, isFrameValue } from './FrameValue'\nimport {\n  SpringPhase,\n  CREATED,\n  IDLE,\n  ACTIVE,\n  PAUSED,\n  DISPOSED,\n} from './SpringPhase'\nimport {\n  AnimationRange,\n  EventProp,\n  OnRest,\n  SpringDefaultProps,\n  SpringUpdate,\n  VelocityProp,\n  AnimationResolver,\n} from './types'\nimport {\n  AsyncResult,\n  getCombinedResult,\n  getCancelledResult,\n  getFinishedResult,\n  getNoopResult,\n} from './AnimationResult'\n\ndeclare const console: any\n\n/**\n * Only numbers, strings, and arrays of numbers/strings are supported.\n * Non-animatable strings are also supported.\n */\nexport class SpringValue<T = any> extends FrameValue<T> {\n  /** The property name used when `to` or `from` is an object. Useful when debugging too. */\n  key?: string\n\n  /** The animation state */\n  animation = new Animation<T>()\n\n  /** The queue of pending props */\n  queue?: SpringUpdate<T>[]\n\n  /** The lifecycle phase of this spring */\n  protected _phase: SpringPhase = CREATED\n\n  /** The state for `runAsync` calls */\n  protected _state: RunAsyncState<T> = {\n    pauseQueue: new Set(),\n    resumeQueue: new Set(),\n  }\n\n  /** Some props have customizable default values */\n  protected _defaultProps = {} as SpringDefaultProps<T>\n\n  /** The counter for tracking `scheduleProps` calls */\n  protected _lastCallId = 0\n\n  /** The last `scheduleProps` call that changed the `to` prop */\n  protected _lastToId = 0\n\n  constructor(from: Exclude<T, object>, props?: SpringUpdate<T>)\n  constructor(props?: SpringUpdate<T>)\n  constructor(arg1?: any, arg2?: any) {\n    super()\n    if (!is.und(arg1) || !is.und(arg2)) {\n      const props = is.obj(arg1) ? { ...arg1 } : { ...arg2, from: arg1 }\n      props.default = true\n      this.start(props)\n    }\n  }\n\n  get idle() {\n    return !this.is(ACTIVE) && !this._state.asyncTo\n  }\n\n  get goal() {\n    return getFluidValue(this.animation.to)\n  }\n\n  get velocity(): VelocityProp<T> {\n    const node = getAnimated(this)!\n    return (node instanceof AnimatedValue\n      ? node.lastVelocity || 0\n      : node.getPayload().map(node => node.lastVelocity || 0)) as any\n  }\n\n  /** Advance the current animation by a number of milliseconds */\n  advance(dt: number) {\n    let idle = true\n    let changed = false\n\n    const anim = this.animation\n    let { config, toValues } = anim\n\n    const payload = getPayload(anim.to)\n    if (!payload) {\n      const toConfig = getFluidConfig(anim.to)\n      if (toConfig) {\n        toValues = toArray(toConfig.get())\n      }\n    }\n\n    anim.values.forEach((node, i) => {\n      if (node.done) return\n\n      // The \"anim.toValues\" array must exist when no parent exists.\n      let to = payload ? payload[i].lastPosition : toValues![i]\n\n      let finished = anim.immediate\n      let position = to\n\n      if (!finished) {\n        position = node.lastPosition\n\n        // Loose springs never move.\n        if (config.tension <= 0) {\n          node.done = true\n          return\n        }\n\n        const elapsed = (node.elapsedTime += dt)\n        const from = anim.fromValues[i]\n\n        const v0 =\n          node.v0 != null\n            ? node.v0\n            : (node.v0 = is.arr(config.velocity)\n                ? config.velocity[i]\n                : config.velocity)\n\n        let velocity: number\n\n        // Duration easing\n        if (!is.und(config.duration)) {\n          let p = config.progress || 0\n          if (config.duration <= 0) p = 1\n          else p += (1 - p) * Math.min(1, elapsed / config.duration)\n\n          position = from + config.easing(p) * (to - from)\n          velocity = (position - node.lastPosition) / dt\n\n          finished = p == 1\n        }\n\n        // Decay easing\n        else if (config.decay) {\n          const decay = config.decay === true ? 0.998 : config.decay\n          const e = Math.exp(-(1 - decay) * elapsed)\n\n          position = from + (v0 / (1 - decay)) * (1 - e)\n          finished = Math.abs(node.lastPosition - position) < 0.1\n\n          // derivative of position\n          velocity = v0 * e\n        }\n\n        // Spring easing\n        else {\n          velocity = node.lastVelocity == null ? v0 : node.lastVelocity\n\n          /** The smallest distance from a value before being treated like said value. */\n          const precision =\n            config.precision ||\n            (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001))\n\n          /** The velocity at which movement is essentially none */\n          const restVelocity = config.restVelocity || precision / 10\n\n          // Bouncing is opt-in (not to be confused with overshooting)\n          const bounceFactor = config.clamp ? 0 : config.bounce!\n          const canBounce = !is.und(bounceFactor)\n\n          /** When `true`, the value is increasing over time */\n          const isGrowing = from == to ? node.v0 > 0 : from < to\n\n          /** When `true`, the velocity is considered moving */\n          let isMoving!: boolean\n\n          /** When `true`, the velocity is being deflected or clamped */\n          let isBouncing = false\n\n          const step = 1 // 1ms\n          const numSteps = Math.ceil(dt / step)\n          for (let n = 0; n < numSteps; ++n) {\n            isMoving = Math.abs(velocity) > restVelocity\n\n            if (!isMoving) {\n              finished = Math.abs(to - position) <= precision\n              if (finished) {\n                break\n              }\n            }\n\n            if (canBounce) {\n              isBouncing = position == to || position > to == isGrowing\n\n              // Invert the velocity with a magnitude, or clamp it.\n              if (isBouncing) {\n                velocity = -velocity * bounceFactor\n                position = to\n              }\n            }\n\n            const springForce = -config.tension * 0.000001 * (position - to)\n            const dampingForce = -config.friction * 0.001 * velocity\n            const acceleration = (springForce + dampingForce) / config.mass // pt/ms^2\n\n            velocity = velocity + acceleration * step // pt/ms\n            position = position + velocity * step\n          }\n        }\n\n        node.lastVelocity = velocity\n\n        if (Number.isNaN(position)) {\n          console.warn(`Got NaN while animating:`, this)\n          finished = true\n        }\n      }\n\n      // Parent springs must finish before their children can.\n      if (payload && !payload[i].done) {\n        finished = false\n      }\n\n      if (finished) {\n        node.done = true\n      } else {\n        idle = false\n      }\n\n      if (node.setValue(position, config.round)) {\n        changed = true\n      }\n    })\n\n    if (idle) {\n      this.finish()\n    } else if (changed) {\n      this._onChange(this.get())\n    }\n    return idle\n  }\n\n  /** Check the current phase */\n  is(phase: SpringPhase) {\n    return this._phase == phase\n  }\n\n  /** Set the current value, while stopping the current animation */\n  set(value: T | FluidValue<T>) {\n    G.batchedUpdates(() => {\n      this._focus(value)\n      if (this._set(value)) {\n        // Ensure change observers are notified. When active,\n        // the \"_stop\" method handles this.\n        if (!this.is(ACTIVE)) {\n          return this._onChange(this.get(), true)\n        }\n      }\n      this._stop()\n    })\n    return this\n  }\n\n  /**\n   * Freeze the active animation in time.\n   * This does nothing when not animating.\n   */\n  pause() {\n    checkDisposed(this, 'pause')\n    if (!this.is(PAUSED)) {\n      this._phase = PAUSED\n      flush(this._state.pauseQueue, onPause => onPause())\n    }\n  }\n\n  /** Resume the animation if paused. */\n  resume() {\n    checkDisposed(this, 'resume')\n    if (this.is(PAUSED)) {\n      this._start()\n      flush(this._state.resumeQueue, onResume => onResume())\n    }\n  }\n\n  /**\n   * Skip to the end of the current animation.\n   *\n   * All `onRest` callbacks are passed `{finished: true}`\n   */\n  finish(to?: T | FluidValue<T>) {\n    this.resume()\n    if (this.is(ACTIVE)) {\n      const anim = this.animation\n\n      // Decay animations have an implicit goal.\n      if (!anim.config.decay && is.und(to)) {\n        to = anim.to\n      }\n\n      // Set the value if we can.\n      if (!is.und(to)) {\n        this._set(to)\n      }\n\n      G.batchedUpdates(() => {\n        // Ensure the \"onStart\" and \"onRest\" props are called.\n        if (!anim.changed) {\n          anim.changed = true\n          if (anim.onStart) {\n            anim.onStart(this)\n          }\n        }\n\n        // Exit the frameloop.\n        this._stop()\n      })\n    }\n    return this\n  }\n\n  /** Push props into the pending queue. */\n  update(props: SpringUpdate<T>) {\n    checkDisposed(this, 'update')\n    const queue = this.queue || (this.queue = [])\n    queue.push(props)\n    return this\n  }\n\n  /**\n   * Update this value's animation using the queue of pending props,\n   * and unpause the current animation (if one is frozen).\n   *\n   * When arguments are passed, a new animation is created, and the\n   * queued animations are left alone.\n   */\n  start(): AsyncResult<T>\n\n  start(props: SpringUpdate<T>): AsyncResult<T>\n\n  start(to: Animatable<T>, props?: SpringUpdate<T>): AsyncResult<T>\n\n  async start(to?: SpringUpdate<T> | Animatable<T>, arg2?: SpringUpdate<T>) {\n    checkDisposed(this, 'start')\n\n    let queue: SpringUpdate<T>[]\n    if (!is.und(to)) {\n      queue = [is.obj(to) ? (to as any) : { ...arg2, to }]\n    } else {\n      queue = this.queue || []\n      this.queue = []\n    }\n\n    const results = await Promise.all(queue.map(props => this._update(props)))\n    return getCombinedResult(this, results)\n  }\n\n  /**\n   * Stop the current animation, and cancel any delayed updates.\n   *\n   * Pass `true` to call `onRest` with `cancelled: true`.\n   */\n  stop(cancel?: boolean) {\n    if (!this.is(DISPOSED)) {\n      cancelAsync(this._state, this._lastCallId)\n\n      // Ensure the `to` value equals the current value.\n      this._focus(this.get())\n\n      // Exit the frameloop and notify `onRest` listeners.\n      G.batchedUpdates(() => this._stop(cancel))\n    }\n    return this\n  }\n\n  /** Restart the animation. */\n  reset() {\n    this._update({ reset: true })\n  }\n\n  /** Prevent future animations, and stop the current animation */\n  dispose() {\n    if (!this.is(DISPOSED)) {\n      if (this.animation) {\n        // Prevent \"onRest\" calls when disposed.\n        this.animation.onRest = []\n      }\n      this.stop()\n      this._phase = DISPOSED\n    }\n  }\n\n  /** @internal */\n  onParentChange(event: FrameValue.Event) {\n    super.onParentChange(event)\n    if (event.type == 'change') {\n      if (!this.is(ACTIVE)) {\n        this._reset()\n        if (!this.is(PAUSED)) {\n          this._start()\n        }\n      }\n    } else if (event.type == 'priority') {\n      this.priority = event.priority + 1\n    }\n  }\n\n  /**\n   * Parse the `to` and `from` range from the given `props` object.\n   *\n   * This also ensures the initial value is available to animated components\n   * during the render phase.\n   */\n  protected _prepareNode({\n    to,\n    from,\n    reverse,\n  }: {\n    to?: any\n    from?: any\n    reverse?: boolean\n  }) {\n    const key = this.key || ''\n\n    to = !is.obj(to) || getFluidConfig(to) ? to : to[key]\n    from = !is.obj(from) || getFluidConfig(from) ? from : from[key]\n\n    // Create the range now to avoid \"reverse\" logic.\n    const range = { to, from }\n\n    // Before ever animating, this method ensures an `Animated` node\n    // exists and keeps its value in sync with the \"from\" prop.\n    if (this.is(CREATED)) {\n      if (reverse) [to, from] = [from, to]\n      from = getFluidValue(from)\n\n      const node = this._updateNode(is.und(from) ? getFluidValue(to) : from)\n      if (node && !is.und(from)) {\n        node.setValue(from)\n      }\n    }\n\n    return range\n  }\n\n  /**\n   * Create an `Animated` node if none exists or the given value has an\n   * incompatible type. Do nothing if `value` is undefined.\n   *\n   * The newest `Animated` node is returned.\n   */\n  protected _updateNode(value: any): Animated | undefined {\n    let node = getAnimated(this)\n    if (!is.und(value)) {\n      const nodeType = this._getNodeType(value)\n      if (!node || node.constructor !== nodeType) {\n        setAnimated(this, (node = nodeType.create(value)))\n      }\n    }\n    return node\n  }\n\n  /** Return the `Animated` node constructor for a given value */\n  protected _getNodeType(value: T | FluidValue<T>): AnimatedType {\n    const parentNode = getAnimated(value)\n    return parentNode\n      ? (parentNode.constructor as any)\n      : is.arr(value)\n      ? AnimatedArray\n      : isAnimatedString(value)\n      ? AnimatedString\n      : AnimatedValue\n  }\n\n  /** Schedule an animation to run after an optional delay */\n  protected _update(props: SpringUpdate<T>, isLoop?: boolean): AsyncResult<T> {\n    type DefaultProps = typeof defaultProps\n    const defaultProps = this._defaultProps\n    const mergeDefaultProp = (key: keyof DefaultProps) => {\n      const value = getDefaultProp(props, key)\n      if (!is.und(value)) {\n        defaultProps[key] = value as any\n      }\n      // For `cancel` and `pause`, a truthy default always wins.\n      if (defaultProps[key]) {\n        props[key] = defaultProps[key] as any\n      }\n    }\n\n    // These props are coerced into booleans by the `scheduleProps` function,\n    // so they need their default values processed before then.\n    mergeDefaultProp('cancel')\n    mergeDefaultProp('pause')\n\n    // Ensure the initial value can be accessed by animated components.\n    const range = this._prepareNode(props)\n\n    return scheduleProps<T>(++this._lastCallId, {\n      key: this.key,\n      props,\n      state: this._state,\n      actions: {\n        pause: this.pause.bind(this),\n        resume: this.resume.bind(this),\n        start: this._merge.bind(this, range),\n      },\n    }).then(result => {\n      if (props.loop && result.finished && !(isLoop && result.noop)) {\n        const nextProps = createLoopUpdate(props)\n        if (nextProps) {\n          return this._update(nextProps, true)\n        }\n      }\n      return result\n    })\n  }\n\n  /** Merge props into the current animation */\n  protected _merge(\n    range: AnimationRange<T>,\n    props: RunAsyncProps<T>,\n    resolve: AnimationResolver<T>\n  ): void {\n    // The \"cancel\" prop cancels all pending delays and it forces the\n    // active animation to stop where it is.\n    if (props.cancel) {\n      this.stop(true)\n      return resolve(getCancelledResult(this))\n    }\n\n    const { key, animation: anim } = this\n    const defaultProps = this._defaultProps\n\n    /** The \"to\" prop is defined. */\n    const hasToProp = !is.und(range.to)\n\n    /** The \"from\" prop is defined. */\n    const hasFromProp = !is.und(range.from)\n\n    // Avoid merging other props if implicitly prevented, except\n    // when both the \"to\" and \"from\" props are undefined.\n    if (hasToProp || hasFromProp) {\n      if (props.callId > this._lastToId) {\n        this._lastToId = props.callId\n      } else {\n        return resolve(getCancelledResult(this))\n      }\n    }\n\n    /** Get the value of a prop, or its default value */\n    const get = <K extends keyof SpringDefaultProps>(prop: K) =>\n      !is.und(props[prop]) ? props[prop] : defaultProps[prop]\n\n    // Call \"onDelayEnd\" before merging props, but after cancellation checks.\n    const onDelayEnd = coerceEventProp(get('onDelayEnd'), key!)\n    if (onDelayEnd) {\n      onDelayEnd(props, this)\n    }\n\n    if (props.default) {\n      mergeDefaultProps(defaultProps, props, ['pause', 'cancel'])\n    }\n\n    const { to: prevTo, from: prevFrom } = anim\n    let { to = prevTo, from = prevFrom } = range\n\n    // Focus the \"from\" value if changing without a \"to\" value.\n    if (hasFromProp && !hasToProp) {\n      to = from\n    }\n\n    // Flip the current range if \"reverse\" is true.\n    if (props.reverse) [to, from] = [from, to]\n\n    /** The \"from\" value is changing. */\n    const hasFromChanged = !isEqual(from, prevFrom)\n\n    if (hasFromChanged) {\n      anim.from = from\n    }\n\n    /** The \"to\" value is changing. */\n    const hasToChanged = !isEqual(to, prevTo)\n\n    if (hasToChanged) {\n      this._focus(to)\n    }\n\n    // Both \"from\" and \"to\" can use a fluid config (thanks to http://npmjs.org/fluids).\n    const toConfig = getFluidConfig(to)\n    const fromConfig = getFluidConfig(from)\n\n    if (fromConfig) {\n      from = fromConfig.get()\n    }\n\n    /** The \"to\" prop is async. */\n    const hasAsyncTo = is.arr(props.to) || is.fun(props.to)\n\n    const { config } = anim\n    const { decay, velocity } = config\n\n    // The \"runAsync\" function treats the \"config\" prop as a default,\n    // so we must avoid merging it when the \"to\" prop is async.\n    if (props.config && !hasAsyncTo) {\n      mergeConfig(\n        config,\n        callProp(props.config, key!),\n        // Avoid calling the same \"config\" prop twice.\n        props.config !== defaultProps.config\n          ? callProp(defaultProps.config, key!)\n          : void 0\n      )\n    }\n\n    // This instance might not have its Animated node yet. For example,\n    // the constructor can be given props without a \"to\" or \"from\" value.\n    let node = getAnimated(this)\n    if (!node || is.und(to)) {\n      return resolve(getFinishedResult(this, true))\n    }\n\n    /** When true, start at the \"from\" value. */\n    const reset =\n      // When `reset` is undefined, the `from` prop implies `reset: true`,\n      // except for declarative updates. When `reset` is defined, there\n      // must exist a value to animate from.\n      is.und(props.reset)\n        ? hasFromProp && !props.default\n        : !is.und(from) && matchProp(props.reset, key)\n\n    // The current value, where the animation starts from.\n    const value = reset ? (from as T) : this.get()\n\n    // The animation ends at this value, unless \"to\" is fluid.\n    const goal = computeGoal<any>(to)\n\n    // Only specific types can be animated to/from.\n    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal)\n\n    // When true, the value changes instantly on the next frame.\n    const immediate =\n      !hasAsyncTo &&\n      (!isAnimatable ||\n        matchProp(defaultProps.immediate || props.immediate, key))\n\n    if (hasToChanged) {\n      if (immediate) {\n        node = this._updateNode(goal)!\n      } else {\n        const nodeType = this._getNodeType(to)\n        if (nodeType !== node.constructor) {\n          throw Error(\n            `Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the \"to\" prop suggests`\n          )\n        }\n      }\n    }\n\n    // The type of Animated node for the goal value.\n    const goalType = node.constructor\n\n    // When the goal value is fluid, we don't know if its value\n    // will change before the next animation frame, so it always\n    // starts the animation to be safe.\n    let started = !!toConfig\n    let finished = false\n\n    if (!started) {\n      // When true, the current value has probably changed.\n      const hasValueChanged = reset || (this.is(CREATED) && hasFromChanged)\n\n      // When the \"to\" value or current value are changed,\n      // start animating if not already finished.\n      if (hasToChanged || hasValueChanged) {\n        finished = isEqual(computeGoal(value), goal)\n        started = !finished\n      }\n\n      // Changing \"decay\" or \"velocity\" starts the animation.\n      if (\n        !isEqual(config.decay, decay) ||\n        !isEqual(config.velocity, velocity)\n      ) {\n        started = true\n      }\n    }\n\n    // When an active animation changes its goal to its current value:\n    if (finished && this.is(ACTIVE)) {\n      // Avoid an abrupt stop unless the animation is being reset.\n      if (anim.changed && !reset) {\n        started = true\n      }\n      // Stop the animation before its first frame.\n      else if (!started) {\n        this._stop()\n      }\n    }\n\n    if (!hasAsyncTo) {\n      // Make sure our \"toValues\" are updated even if our previous\n      // \"to\" prop is a fluid value whose current value is also ours.\n      if (started || getFluidConfig(prevTo)) {\n        anim.values = node.getPayload()\n        anim.toValues = toConfig\n          ? null\n          : goalType == AnimatedString\n          ? [1]\n          : toArray(goal)\n      }\n\n      anim.immediate = immediate\n\n      anim.onStart = coerceEventProp(get('onStart'), key)\n      anim.onChange = coerceEventProp(get('onChange'), key)\n\n      // The \"reset\" prop tries to reuse the old \"onRest\" prop,\n      // unless you defined a new \"onRest\" prop.\n      const onRestQueue = anim.onRest\n      const onRest =\n        reset && !props.onRest\n          ? onRestQueue[0] || noop\n          : checkFinishedOnRest(coerceEventProp(get('onRest'), key), this)\n\n      // In most cases, the animation after this one won't reuse our\n      // \"onRest\" prop. Instead, the _default_ \"onRest\" prop is used\n      // when the next animation has an undefined \"onRest\" prop.\n      if (started) {\n        anim.onRest = [onRest, checkFinishedOnRest(resolve, this)]\n\n        // Flush the \"onRest\" queue for the previous animation.\n        let onRestIndex = reset ? 0 : 1\n        if (onRestIndex < onRestQueue.length) {\n          G.batchedUpdates(() => {\n            for (; onRestIndex < onRestQueue.length; onRestIndex++) {\n              onRestQueue[onRestIndex]()\n            }\n          })\n        }\n      }\n      // The \"onRest\" prop is always first, and it can be updated even\n      // if a new animation is not started by this update.\n      else if (reset || props.onRest) {\n        anim.onRest[0] = onRest\n      }\n    }\n\n    // By this point, every prop has been merged.\n    const onProps = coerceEventProp(get('onProps'), key)\n    if (onProps) {\n      onProps(props, this)\n    }\n\n    // Update our node even if the animation is idle.\n    if (reset) {\n      node.setValue(value)\n    }\n\n    if (hasAsyncTo) {\n      resolve(runAsync(props.to, props, this._state, this))\n    }\n\n    // Start an animation\n    else if (started) {\n      // Must be idle for \"onStart\" to be called again.\n      if (reset) this._phase = IDLE\n\n      this._reset()\n      this._start()\n    }\n\n    // Postpone promise resolution until the animation is finished,\n    // so that no-op updates still resolve at the expected time.\n    else if (this.is(ACTIVE) && !hasToChanged) {\n      anim.onRest.push(checkFinishedOnRest(resolve, this))\n    }\n\n    // Resolve our promise immediately.\n    else {\n      resolve(getNoopResult(this, value))\n    }\n  }\n\n  /** Update the `animation.to` value, which might be a `FluidValue` */\n  protected _focus(value: T | FluidValue<T>) {\n    const anim = this.animation\n    if (value !== anim.to) {\n      let config = getFluidConfig(anim.to)\n      if (config) {\n        config.removeChild(this)\n      }\n\n      anim.to = value\n\n      let priority = 0\n      if ((config = getFluidConfig(value))) {\n        config.addChild(this)\n        if (isFrameValue(value)) {\n          priority = (value.priority || 0) + 1\n        }\n      }\n      this.priority = priority\n    }\n  }\n\n  /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */\n  protected _set(value: T | FluidValue<T>) {\n    const config = getFluidConfig(value)\n    if (config) {\n      value = config.get()\n    }\n    const node = getAnimated(this)\n    const oldValue = node && node.getValue()\n    if (node) {\n      node.setValue(value)\n    } else {\n      this._updateNode(value)\n    }\n    return !isEqual(value, oldValue)\n  }\n\n  protected _onChange(value: T, idle = false) {\n    const anim = this.animation\n\n    // The \"onStart\" prop is called on the first change after entering the\n    // frameloop, but never for immediate animations.\n    if (!anim.changed && !idle) {\n      anim.changed = true\n      if (anim.onStart) {\n        anim.onStart(this)\n      }\n    }\n\n    if (anim.onChange) {\n      anim.onChange(value, this)\n    }\n\n    super._onChange(value, idle)\n  }\n\n  protected _reset() {\n    const anim = this.animation\n\n    // Reset the state of each Animated node.\n    getAnimated(this)!.reset(anim.to)\n\n    // Ensure the `onStart` prop will be called.\n    if (!this.is(ACTIVE)) {\n      anim.changed = false\n    }\n\n    // Use the current values as the from values.\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map(node => node.lastPosition)\n    }\n\n    super._reset()\n  }\n\n  protected _start() {\n    if (!this.is(ACTIVE)) {\n      this._phase = ACTIVE\n\n      super._start()\n\n      // The \"skipAnimation\" global avoids the frameloop.\n      if (G.skipAnimation) {\n        this.finish()\n      } else {\n        G.frameLoop.start(this)\n      }\n    }\n  }\n\n  /**\n   * Exit the frameloop and notify `onRest` listeners.\n   *\n   * Always wrap `_stop` calls with `batchedUpdates`.\n   */\n  protected _stop(cancel?: boolean) {\n    this.resume()\n    if (this.is(ACTIVE)) {\n      this._phase = IDLE\n\n      // Always let change observers know when a spring becomes idle.\n      this._onChange(this.get(), true)\n\n      const anim = this.animation\n      each(anim.values, node => {\n        node.done = true\n      })\n\n      const onRestQueue = anim.onRest\n      if (onRestQueue.length) {\n        // Preserve the \"onRest\" prop when the goal is dynamic.\n        anim.onRest = [anim.toValues ? noop : onRestQueue[0]]\n\n        // Never call the \"onRest\" prop for no-op animations.\n        if (!anim.changed) {\n          onRestQueue[0] = noop\n        }\n\n        each(onRestQueue, onRest => onRest(cancel))\n      }\n    }\n  }\n}\n\nfunction checkDisposed(spring: SpringValue, name: string) {\n  if (spring.is(DISPOSED)) {\n    throw Error(\n      `Cannot call \"${name}\" of disposed \"${spring.constructor.name}\" object`\n    )\n  }\n}\n\n/** Coerce an event prop to an event handler */\nfunction coerceEventProp<T extends Function>(\n  prop: EventProp<T> | undefined,\n  key: string | undefined\n) {\n  return is.fun(prop) ? prop : key && prop ? prop[key] : undefined\n}\n\n/**\n * The \"finished\" value is determined by each \"onRest\" handler,\n * based on whether the current value equals the goal value that\n * was calculated at the time the \"onRest\" handler was set.\n */\nconst checkFinishedOnRest = <T>(\n  onRest: OnRest<T> | undefined,\n  spring: SpringValue<T>\n) => {\n  const { to } = spring.animation\n  return onRest\n    ? (cancel?: boolean) => {\n        if (cancel) {\n          onRest(getCancelledResult(spring))\n        } else {\n          const goal = computeGoal(to)\n          const value = computeGoal(spring.get())\n          const finished = isEqual(value, goal)\n          onRest(getFinishedResult(spring, finished))\n        }\n      }\n    : noop\n}\n\nexport function createLoopUpdate<T>(\n  props: T & { loop?: any; to?: any; from?: any; reverse?: any },\n  loop = props.loop,\n  to = props.to\n): T | undefined {\n  let loopRet = callProp(loop)\n  if (loopRet) {\n    const overrides = loopRet !== true && inferTo(loopRet)\n    const reverse = (overrides || props).reverse\n    const reset = !overrides || overrides.reset\n    return createUpdate({\n      ...props,\n      loop,\n\n      // Avoid updating default props when looping.\n      default: false,\n\n      // For the \"reverse\" prop to loop as expected, the \"to\" prop\n      // must be undefined. The \"reverse\" prop is ignored when the\n      // \"to\" prop is an array or function.\n      to: !reverse || is.arr(to) || is.fun(to) ? to : undefined,\n\n      // Avoid defining the \"from\" prop if a reset is unwanted.\n      from: reset ? props.from : undefined,\n      reset,\n\n      // The \"loop\" prop can return a \"useSpring\" props object to\n      // override any of the original props.\n      ...overrides,\n    })\n  }\n}\n\n/**\n * Return a new object based on the given `props`.\n *\n * - All unreserved props are moved into the `to` prop object.\n * - The `to` and `from` props are deleted when falsy.\n * - The `keys` prop is set to an array of affected keys,\n *   or `null` if all keys are affected.\n */\nexport function createUpdate(props: any) {\n  const { to, from } = (props = inferTo(props))\n\n  // Collect the keys affected by this update.\n  const keys = new Set<string>()\n\n  if (from) {\n    findDefined(from, keys)\n  } else {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.from\n  }\n\n  if (is.obj(to)) {\n    findDefined(to, keys)\n  } else if (!to) {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.to\n  }\n\n  // The \"keys\" prop helps in applying updates to affected keys only.\n  props.keys = keys.size ? Array.from(keys) : null\n\n  return props\n}\n\n/**\n * A modified version of `createUpdate` meant for declarative APIs.\n */\nexport function declareUpdate(props: any) {\n  const update = createUpdate(props)\n  if (is.und(update.default)) {\n    update.default = getDefaultProps(update, [\n      // Avoid forcing `immediate: true` onto imperative updates.\n      update.immediate === true && 'immediate',\n    ])\n  }\n  return update\n}\n\n/** Find keys with defined values */\nfunction findDefined(values: any, keys: Set<string>) {\n  each(values, (value, key) => value != null && keys.add(key as any))\n}\n","import { is, each, flush, OneOrMore, toArray, UnknownProps, noop } from '@react-spring/shared'\nimport * as G from '@react-spring/shared/globals'\n\nimport { Lookup, Falsy } from './types/common'\nimport { hasDefaultProp } from './helpers'\nimport { FrameValue } from './FrameValue'\nimport { SpringPhase, CREATED, ACTIVE, IDLE } from './SpringPhase'\nimport { SpringValue, createLoopUpdate, createUpdate } from './SpringValue'\nimport {\n  getCombinedResult,\n  AnimationResult,\n  AsyncResult,\n} from './AnimationResult'\nimport { runAsync, RunAsyncState, cancelAsync } from './runAsync'\nimport { scheduleProps } from './scheduleProps'\nimport {\n  ControllerFlushFn,\n  ControllerUpdate,\n  OnRest,\n  SpringValues,\n} from './types'\n\n/** Events batched by the `Controller` class */\nconst BATCHED_EVENTS = ['onStart', 'onChange', 'onRest'] as const\n\nlet nextId = 1\n\n/** Queue of pending updates for a `Controller` instance. */\nexport interface ControllerQueue<State extends Lookup = Lookup>\n  extends Array<\n    ControllerUpdate<State> & {\n      /** The keys affected by this update. When null, all keys are affected. */\n      keys: string[] | null\n    }\n  > {}\n\nexport class Controller<State extends Lookup = Lookup>\n  implements FrameValue.Observer {\n  readonly id = nextId++\n\n  /** The animated values */\n  springs: SpringValues<State> = {} as any\n\n  /** The queue of props passed to the `update` method. */\n  queue: ControllerQueue<State> = []\n\n  /** Custom handler for flushing update queues */\n  protected _flush?: ControllerFlushFn<State>\n\n  /** These props are used by all future spring values */\n  protected _initialProps?: Lookup\n\n  /** The combined phase of our spring values */\n  protected _phase: SpringPhase = CREATED\n\n  /** The counter for tracking `scheduleProps` calls */\n  protected _lastAsyncId = 0\n\n  /** The values currently being animated */\n  protected _active = new Set<FrameValue>()\n\n  /** State used by the `runAsync` function */\n  protected _state: RunAsyncState<State> = {\n    pauseQueue: new Set(),\n    resumeQueue: new Set(),\n  }\n\n  /** The event queues that are flushed once per frame maximum */\n  protected _events = {\n    onStart: new Set<Function>(),\n    onChange: new Set<Function>(),\n    onRest: new Map<OnRest, AnimationResult>(),\n  }\n\n  constructor(\n    props?: ControllerUpdate<State> | null,\n    flush?: ControllerFlushFn<State>\n  ) {\n    this._onFrame = this._onFrame.bind(this)\n    if (flush) {\n      this._flush = flush\n    }\n    if (props) {\n      this.start(props)\n    }\n  }\n\n  /**\n   * Equals `true` when no spring values are in the frameloop, and\n   * no async animation is currently active.\n   */\n  get idle() {\n    return (\n      !this._state.asyncTo &&\n      Object.values(this.springs as Lookup<SpringValue>).every(\n        spring => spring.idle\n      )\n    )\n  }\n\n  /** Check the current phase */\n  is(phase: SpringPhase) {\n    return this._phase == phase\n  }\n\n  /** Get the current values of our springs */\n  get(): State & UnknownProps {\n    const values: any = {}\n    this.each((spring, key) => (values[key] = spring.get()))\n    return values\n  }\n\n  /** Push an update onto the queue of each value. */\n  update(props: ControllerUpdate<State> | Falsy) {\n    if (props) this.queue.push(createUpdate(props))\n    return this\n  }\n\n  /**\n   * Start the queued animations for every spring, and resolve the returned\n   * promise once all queued animations have finished or been cancelled.\n   *\n   * When you pass a queue (instead of nothing), that queue is used instead of\n   * the queued animations added with the `update` method, which are left alone.\n   */\n  start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<State> {\n    const queue = props ? toArray<any>(props).map(createUpdate) : this.queue\n    if (!props) {\n      this.queue = []\n    }\n    if (this._flush) {\n      return this._flush(this, queue)\n    }\n    prepareKeys(this, queue)\n    return flushUpdateQueue(this, queue)\n  }\n\n  /** Stop one animation, some animations, or all animations */\n  stop(keys?: OneOrMore<string>) {\n    if (is.und(keys)) {\n      this.each(spring => spring.stop())\n      cancelAsync(this._state, this._lastAsyncId)\n    } else {\n      const springs = this.springs as Lookup<SpringValue>\n      each(toArray(keys), key => springs[key].stop())\n    }\n    return this\n  }\n\n  /** Freeze the active animation in time */\n  pause(keys?: OneOrMore<string>) {\n    if (is.und(keys)) {\n      this.each(spring => spring.pause())\n    } else {\n      const springs = this.springs as Lookup<SpringValue>\n      each(toArray(keys), key => springs[key].pause())\n    }\n    return this\n  }\n\n  /** Resume the animation if paused. */\n  resume(keys?: OneOrMore<string>) {\n    if (is.und(keys)) {\n      this.each(spring => spring.resume())\n    } else {\n      const springs = this.springs as Lookup<SpringValue>\n      each(toArray(keys), key => springs[key].resume())\n    }\n    return this\n  }\n\n  /** Restart every animation. */\n  reset() {\n    this.each(spring => spring.reset())\n    // TODO: restart async \"to\" prop\n    return this\n  }\n\n  /** Call a function once per spring value */\n  each(iterator: (spring: SpringValue, key: string) => void) {\n    each(this.springs, iterator as any)\n  }\n\n  /** Destroy every spring in this controller */\n  dispose() {\n    this._state.asyncTo = undefined\n    this.each(spring => spring.dispose())\n    this.springs = {} as any\n  }\n\n  /** @internal Called at the end of every animation frame */\n  protected _onFrame() {\n    const { onStart, onChange, onRest } = this._events\n\n    const isActive = this._active.size > 0\n    if (isActive && this._phase != ACTIVE) {\n      this._phase = ACTIVE\n      flush(onStart, onStart => onStart(this))\n    }\n\n    const values = (onChange.size || (!isActive && onRest.size)) && this.get()\n    flush(onChange, onChange => onChange(values))\n\n    // The \"onRest\" queue is only flushed when all springs are idle.\n    if (!isActive) {\n      this._phase = IDLE\n      flush(onRest, ([onRest, result]) => {\n        result.value = values\n        onRest(result)\n      })\n    }\n  }\n\n  /** @internal */\n  onParentChange(event: FrameValue.Event) {\n    if (event.type == 'change') {\n      this._active[event.idle ? 'delete' : 'add'](event.parent)\n      G.frameLoop.onFrame(this._onFrame)\n    }\n  }\n}\n\n/**\n * Warning: Props might be mutated.\n */\nexport function flushUpdateQueue(\n  ctrl: Controller<any>,\n  queue: ControllerQueue\n) {\n  return Promise.all(\n    queue.map(props => flushUpdate(ctrl, props))\n  ).then(results => getCombinedResult(ctrl, results))\n}\n\n/**\n * Warning: Props might be mutated.\n *\n * Process a single set of props using the given controller.\n *\n * The returned promise resolves to `true` once the update is\n * applied and any animations it starts are finished without being\n * stopped or cancelled.\n */\nexport function flushUpdate(\n  ctrl: Controller<any>,\n  props: ControllerQueue[number],\n  isLoop?: boolean\n): AsyncResult {\n  const { to, loop, onRest } = props\n\n  // Looping must be handled in this function, or else the values\n  // would end up looping out-of-sync in many common cases.\n  if (loop) {\n    props.loop = false\n  }\n\n  const asyncTo = is.arr(to) || is.fun(to) ? to : undefined\n  if (asyncTo) {\n    props.to = undefined\n    props.onRest = undefined\n  } else {\n    // For certain events, use batching to prevent multiple calls per frame.\n    // However, batching is avoided when the `to` prop is async, because any\n    // event props are used as default props instead.\n    each(BATCHED_EVENTS, key => {\n      const handler: any = props[key]\n      if (is.fun(handler)) {\n        const queue = ctrl['_events'][key]\n        if (queue instanceof Set) {\n          props[key] = () => queue.add(handler)\n        } else {\n          props[key] = (({ finished, cancelled }: AnimationResult) => {\n            const result = queue.get(handler)\n            if (result) {\n              if (!finished) result.finished = false\n              if (cancelled) result.cancelled = true\n            } else {\n              // The \"value\" is set before the \"handler\" is called.\n              queue.set(handler, {\n                value: null,\n                finished,\n                cancelled,\n              })\n            }\n          }) as any\n        }\n      }\n    })\n  }\n\n  const keys = props.keys || Object.keys(ctrl.springs)\n  const promises = keys.map(key => ctrl.springs[key]!.start(props as any))\n\n  // Schedule the \"asyncTo\" if defined.\n  const state = ctrl['_state']\n  if (asyncTo) {\n    promises.push(\n      scheduleProps(++ctrl['_lastAsyncId'], {\n        props,\n        state,\n        actions: {\n          pause: noop,\n          resume: noop,\n          start(props, resolve) {\n            props.onRest = onRest as any\n            if (!props.cancel) {\n              resolve(runAsync(asyncTo, props, state, ctrl))\n            }\n            // Prevent `cancel: true` from ending the current `runAsync` call,\n            // except when the default `cancel` prop is being set.\n            else if (hasDefaultProp(props, 'cancel')) {\n              cancelAsync(state, props.callId)\n            }\n          },\n        },\n      })\n    )\n  }\n  // Respect the `cancel` prop when no keys are affected.\n  else if (!props.keys && props.cancel === true) {\n    cancelAsync(state, ctrl['_lastAsyncId'])\n  }\n\n  return Promise.all(promises).then(results => {\n    const result = getCombinedResult<any>(ctrl, results)\n    if (loop && result.finished && !(isLoop && result.noop)) {\n      const nextProps = createLoopUpdate(props, loop, to)\n      if (nextProps) {\n        prepareKeys(ctrl, [nextProps])\n        return flushUpdate(ctrl, nextProps, true)\n      }\n    }\n    return result\n  })\n}\n\n/**\n * From an array of updates, get the map of `SpringValue` objects\n * by their keys. Springs are created when any update wants to\n * animate a new key.\n *\n * Springs created by `getSprings` are neither cached nor observed\n * until they're given to `setSprings`.\n */\nexport function getSprings<State extends Lookup>(\n  ctrl: Controller<State>,\n  props?: OneOrMore<ControllerUpdate<State>>\n) {\n  const springs = { ...ctrl.springs }\n  if (props) {\n    each(toArray(props), (props: any) => {\n      if (is.und(props.keys)) {\n        props = createUpdate(props)\n      }\n      if (!is.obj(props.to)) {\n        // Avoid passing array/function to each spring.\n        props = { ...props, to: undefined }\n      }\n      prepareSprings(springs as any, props, key => {\n        return createSpring(key)\n      })\n    })\n  }\n  return springs\n}\n\n/**\n * Tell a controller to manage the given `SpringValue` objects\n * whose key is not already in use.\n */\nexport function setSprings(\n  ctrl: Controller,\n  springs: SpringValues<UnknownProps>\n) {\n  each(springs, (spring, key) => {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring\n      spring.addChild(ctrl)\n    }\n  })\n}\n\nfunction createSpring(key: string, observer?: FrameValue.Observer) {\n  const spring = new SpringValue()\n  spring.key = key\n  if (observer) {\n    spring.addChild(observer)\n  }\n  return spring\n}\n\n/**\n * Ensure spring objects exist for each defined key.\n *\n * Using the `props`, the `Animated` node of each `SpringValue` may\n * be created or updated.\n */\nfunction prepareSprings(\n  springs: SpringValues,\n  props: ControllerQueue[number],\n  create: (key: string) => SpringValue\n) {\n  if (props.keys) {\n    each(props.keys, key => {\n      const spring = springs[key] || (springs[key] = create(key))\n      spring['_prepareNode'](props)\n    })\n  }\n}\n\n/**\n * Ensure spring objects exist for each defined key, and attach the\n * `ctrl` to them for observation.\n *\n * The queue is expected to contain `createUpdate` results.\n */\nfunction prepareKeys(ctrl: Controller<any>, queue: ControllerQueue[number][]) {\n  each(queue, props => {\n    prepareSprings(ctrl.springs, props, key => {\n      return createSpring(key, ctrl)\n    })\n  })\n}\n","import * as React from 'react'\nimport { useContext, PropsWithChildren } from 'react'\nimport { SpringConfig } from './types'\nimport { useMemo } from './helpers'\n\n/**\n * This context affects all new and existing `SpringValue` objects\n * created with the hook API or the renderprops API.\n */\nexport interface SpringContext {\n  /** Pause all new and existing animations. */\n  pause?: boolean\n  /** Cancel all new and existing animations. */\n  cancel?: boolean\n  /** Force all new and existing animations to be immediate. */\n  immediate?: boolean\n  /** Set the default `config` prop for future animations. */\n  config?: SpringConfig\n}\n\nconst ctx = React.createContext<SpringContext>({})\n\nexport const SpringContext = ({\n  children,\n  ...props\n}: PropsWithChildren<SpringContext>) => {\n  const inherited = useContext(ctx)\n\n  // Memoize the context to avoid unwanted renders.\n  props = useMemo(() => ({ ...inherited, ...props }), [\n    inherited,\n    props.pause,\n    props.cancel,\n    props.immediate,\n    props.config,\n  ])\n\n  const { Provider } = ctx\n  return <Provider value={props}>{children}</Provider>\n}\n\nSpringContext.Provider = ctx.Provider\nSpringContext.Consumer = ctx.Consumer\n\n/** Get the current values of nearest `SpringContext` component. */\nexport const useSpringContext = () => useContext(ctx)\n","import { each, Lookup, UnknownProps } from '@react-spring/shared'\nimport { Controller } from './Controller'\nimport { getProps } from './helpers'\nimport {\n  SpringStartFn,\n  SpringStopFn,\n  SpringPauseFn,\n  SpringResumeFn,\n  SpringsUpdate,\n} from './types'\n\n/**\n * The object attached to the `ref` prop by the `useSprings` hook.\n *\n * The `T` parameter should only contain animated props.\n */\nexport interface SpringHandle<T extends Lookup = UnknownProps> {\n  controllers: ReadonlyArray<Controller<T>>\n  update: (props: SpringsUpdate<T>) => SpringHandle<T>\n  start: SpringStartFn<T>\n  stop: SpringStopFn<T>\n  pause: SpringPauseFn<T>\n  resume: SpringResumeFn<T>\n}\n\n/** Create an imperative API for manipulating an array of `Controller` objects. */\nexport const SpringHandle = {\n  create: (getControllers: () => Controller[]): SpringHandle => ({\n    get controllers() {\n      return getControllers()\n    },\n    update(props) {\n      each(getControllers(), (ctrl, i) => {\n        ctrl.update(getProps(props, i, ctrl))\n      })\n      return this\n    },\n    async start(props) {\n      const results = await Promise.all(\n        getControllers().map((ctrl, i) => {\n          const update = getProps(props, i, ctrl)\n          return ctrl.start(update)\n        })\n      )\n      return {\n        value: results.map(result => result.value),\n        finished: results.every(result => result.finished),\n      }\n    },\n    stop: keys => each(getControllers(), ctrl => ctrl.stop(keys)),\n    pause: keys => each(getControllers(), ctrl => ctrl.pause(keys)),\n    resume: keys => each(getControllers(), ctrl => ctrl.resume(keys)),\n  }),\n}\n","import { useMemo, useState, useRef } from 'react'\nimport { useLayoutEffect } from 'react-layout-effect'\nimport {\n  is,\n  each,\n  usePrev,\n  useOnce,\n  RefProp,\n  UnknownProps,\n  useForceUpdate,\n  Lookup,\n} from '@react-spring/shared'\n\nimport {\n  ControllerFlushFn,\n  PickAnimated,\n  SpringStartFn,\n  SpringStopFn,\n  SpringValues,\n  ControllerUpdate,\n} from '../types'\nimport { UseSpringProps } from './useSpring'\nimport { declareUpdate } from '../SpringValue'\nimport {\n  Controller,\n  getSprings,\n  flushUpdateQueue,\n  setSprings,\n} from '../Controller'\nimport { useMemo as useMemoOne } from '../helpers'\nimport { useSpringContext } from '../SpringContext'\nimport { SpringHandle } from '../SpringHandle'\n\nexport type UseSpringsProps<State extends Lookup = Lookup> = unknown &\n  ControllerUpdate<State> & {\n    ref?: RefProp<SpringHandle<State>>\n  }\n\n/**\n * When the `deps` argument exists, the `props` function is called whenever\n * the `deps` change on re-render.\n *\n * Without the `deps` argument, the `props` function is only called once.\n */\nexport function useSprings<Props extends UseSpringProps>(\n  length: number,\n  props: (i: number, ctrl: Controller) => Props,\n  deps?: readonly any[]\n): PickAnimated<Props> extends infer State\n  ? [SpringValues<State & object>[], SpringStartFn<State>, SpringStopFn<State>]\n  : never\n\n/**\n * Animations are updated on re-render.\n */\nexport function useSprings<Props extends UseSpringsProps>(\n  length: number,\n  props: Props[] & UseSpringsProps<PickAnimated<Props>>[]\n): SpringValues<PickAnimated<Props>>[]\n\n/**\n * When the `deps` argument exists, you get the `update` and `stop` function.\n */\nexport function useSprings<Props extends UseSpringsProps>(\n  length: number,\n  props: Props[] & UseSpringsProps<PickAnimated<Props>>[],\n  deps: readonly any[] | undefined\n): PickAnimated<Props> extends infer State\n  ? [SpringValues<State & object>[], SpringStartFn<State>, SpringStopFn<State>]\n  : never\n\n/** @internal */\nexport function useSprings(\n  length: number,\n  props: any[] | ((i: number, ctrl: Controller) => any),\n  deps?: readonly any[]\n): any {\n  const propsFn = is.fun(props) && props\n  if (propsFn && !deps) deps = []\n\n  interface State {\n    // The controllers used for applying updates.\n    ctrls: Controller[]\n    // The queue of changes to make on commit.\n    queue: Array<() => void>\n    // The flush function used by controllers.\n    flush: ControllerFlushFn<UnknownProps>\n  }\n\n  // Set to 0 to prevent sync flush.\n  const layoutId = useRef(0)\n  const forceUpdate = useForceUpdate()\n\n  // State is updated on commit.\n  const [state] = useState(\n    (): State => ({\n      ctrls: [],\n      queue: [],\n      flush(ctrl, updates) {\n        const springs = getSprings(ctrl, updates)\n\n        // Flushing is postponed until the component's commit phase\n        // if a spring was created since the last commit.\n        const canFlushSync =\n          layoutId.current > 0 &&\n          !state.queue.length &&\n          !Object.keys(springs).some(key => !ctrl.springs[key])\n\n        return canFlushSync\n          ? flushUpdateQueue(ctrl, updates)\n          : new Promise<any>(resolve => {\n              setSprings(ctrl, springs)\n              state.queue.push(() => {\n                resolve(flushUpdateQueue(ctrl, updates))\n              })\n              forceUpdate()\n            })\n      },\n    })\n  )\n\n  // The imperative API ref from the props of the first controller.\n  const refProp = useRef<RefProp<SpringHandle>>()\n\n  const ctrls = [...state.ctrls]\n  const updates: any[] = []\n\n  // Cache old controllers to dispose in the commit phase.\n  const prevLength = usePrev(length) || 0\n  const disposed = ctrls.slice(length, prevLength)\n\n  // Create new controllers when \"length\" increases, and destroy\n  // the affected controllers when \"length\" decreases.\n  useMemoOne(() => {\n    ctrls.length = length\n    declareUpdates(prevLength, length)\n  }, [length])\n\n  // Update existing controllers when \"deps\" are changed.\n  useMemoOne(() => {\n    declareUpdates(0, Math.min(prevLength, length))\n  }, deps)\n\n  /** Fill the `updates` array with declarative updates for the given index range. */\n  function declareUpdates(startIndex: number, endIndex: number) {\n    for (let i = startIndex; i < endIndex; i++) {\n      const ctrl = ctrls[i] || (ctrls[i] = new Controller(null, state.flush))\n\n      let update: UseSpringProps<any> = propsFn\n        ? propsFn(i, ctrl)\n        : (props as any)[i]\n\n      if (update) {\n        update = updates[i] = declareUpdate(update)\n        if (i == 0) {\n          refProp.current = update.ref\n          update.ref = undefined\n        }\n      }\n    }\n  }\n\n  const api = useMemo(() => {\n    return SpringHandle.create(() => state.ctrls)\n  }, [])\n\n  // New springs are created during render so users can pass them to\n  // their animated components, but new springs aren't cached until the\n  // commit phase (see the `useLayoutEffect` callback below).\n  const springs = ctrls.map((ctrl, i) => getSprings(ctrl, updates[i]))\n\n  const context = useSpringContext()\n  useLayoutEffect(() => {\n    layoutId.current++\n\n    // Replace the cached controllers.\n    state.ctrls = ctrls\n\n    // Update the ref prop.\n    if (refProp.current) {\n      refProp.current.current = api\n    }\n\n    // Flush the commit queue.\n    const { queue } = state\n    if (queue.length) {\n      state.queue = []\n      each(queue, cb => cb())\n    }\n\n    // Dispose unused controllers.\n    each(disposed, ctrl => ctrl.dispose())\n\n    // Update existing controllers.\n    each(ctrls, (ctrl, i) => {\n      const values = springs[i]\n      setSprings(ctrl, values)\n\n      // Update the default props.\n      ctrl.start({ default: context })\n\n      // Apply updates created during render.\n      const update = updates[i]\n      if (update) {\n        // Start animating unless a ref exists.\n        if (refProp.current) {\n          ctrl.queue.push(update)\n        } else {\n          ctrl.start(update)\n        }\n      }\n    })\n  })\n\n  // Dispose all controllers on unmount.\n  useOnce(() => () => {\n    each(state.ctrls, ctrl => ctrl.dispose())\n  })\n\n  // Return a deep copy of the `springs` array so the caller can\n  // safely mutate it during render.\n  const values = springs.map(x => ({ ...x }))\n\n  return propsFn || arguments.length == 3\n    ? [values, api.start, api.stop]\n    : values\n}\n","import { is, RefProp, UnknownProps, Remap } from '@react-spring/shared'\n\nimport {\n  ControllerUpdate,\n  PickAnimated,\n  SpringStartFn,\n  SpringStopFn,\n  SpringValues,\n} from '../types'\nimport { Valid } from '../types/common'\nimport { SpringHandle } from '../SpringHandle'\nimport { useSprings } from './useSprings'\n\n/**\n * The props that `useSpring` recognizes.\n */\nexport type UseSpringProps<Props extends object = any> = unknown &\n  PickAnimated<Props> extends infer State\n  ? Remap<\n      ControllerUpdate<State> & {\n        /**\n         * Used to access the imperative API.\n         *\n         * When defined, the render animation won't auto-start.\n         */\n        ref?: RefProp<SpringHandle<State>>\n      }\n    >\n  : never\n\n/**\n * The `props` function is only called on the first render, unless\n * `deps` change (when defined). State is inferred from forward props.\n */\nexport function useSpring<Props extends object>(\n  props: () => (Props & Valid<Props, UseSpringProps<Props>>) | UseSpringProps,\n  deps?: readonly any[] | undefined\n): [\n  SpringValues<PickAnimated<Props>>,\n  SpringStartFn<PickAnimated<Props>>,\n  SpringStopFn<UnknownProps>\n]\n\n/**\n * Updated on every render, with state inferred from forward props.\n */\nexport function useSpring<Props extends object>(\n  props: (Props & Valid<Props, UseSpringProps<Props>>) | UseSpringProps\n): SpringValues<PickAnimated<Props>>\n\n/**\n * Updated only when `deps` change, with state inferred from forwad props.\n */\nexport function useSpring<Props extends object>(\n  props: (Props & Valid<Props, UseSpringProps<Props>>) | UseSpringProps,\n  deps: readonly any[] | undefined\n): [\n  SpringValues<PickAnimated<Props>>,\n  SpringStartFn<PickAnimated<Props>>,\n  SpringStopFn<UnknownProps>\n]\n\n/** @internal */\nexport function useSpring(props: any, deps?: readonly any[]) {\n  const isFn = is.fun(props)\n  const [[values], update, stop] = useSprings(\n    1,\n    isFn ? props : [props],\n    isFn ? deps || [] : deps\n  )\n  return isFn || arguments.length == 2\n    ? ([values, update, stop] as const)\n    : values\n}\n","import { useLayoutEffect } from 'react-layout-effect'\nimport { useCallbackOne } from 'use-memo-one'\nimport { is } from '@react-spring/shared'\n\nimport { Valid } from '../types/common'\nimport {\n  PickAnimated,\n  SpringStartFn,\n  SpringStopFn,\n  SpringValues,\n} from '../types'\nimport { UseSpringProps } from './useSpring'\nimport { Controller } from '../Controller'\nimport { useSprings } from './useSprings'\nimport { getProps } from '../helpers'\n\nexport type UseTrailProps<Props extends object = any> = UseSpringProps<Props>\n\nexport function useTrail<Props extends object>(\n  length: number,\n  props: (\n    i: number,\n    ctrl: Controller\n  ) => UseTrailProps | (Props & Valid<Props, UseTrailProps<Props>>),\n  deps?: readonly any[]\n): PickAnimated<Props> extends infer State\n  ? [SpringValues<State & object>[], SpringStartFn<State>, SpringStopFn<State>]\n  : never\n\nexport function useTrail<Props extends object>(\n  length: number,\n  props: UseTrailProps | (Props & Valid<Props, UseTrailProps<Props>>)\n): SpringValues<PickAnimated<Props>>[]\n\nexport function useTrail<Props extends object>(\n  length: number,\n  props: UseTrailProps | (Props & Valid<Props, UseTrailProps<Props>>),\n  deps: readonly any[]\n): PickAnimated<Props> extends infer State\n  ? [SpringValues<State & object>[], SpringStartFn<State>, SpringStopFn<State>]\n  : never\n\nexport function useTrail(\n  length: number,\n  propsArg: unknown,\n  deps?: readonly any[]\n) {\n  const propsFn = is.fun(propsArg) && propsArg\n  if (propsFn && !deps) deps = []\n\n  const ctrls: Controller[] = []\n  const result = useSprings(\n    length,\n    (i, ctrl) => {\n      ctrls[i] = ctrl\n      return getProps(propsArg, i, ctrl) as any\n    },\n    // Ensure the props function is called when no deps exist.\n    // This works around the 3 argument rule.\n    deps || [{}]\n  )\n\n  useLayoutEffect(() => {\n    const reverse = is.obj(propsArg) && propsArg.reverse\n    for (let i = 0; i < ctrls.length; i++) {\n      const parent = ctrls[i + (reverse ? 1 : -1)]\n      if (parent) ctrls[i].update({ to: parent.springs }).start()\n    }\n  }, deps)\n\n  if (propsFn || arguments.length == 3) {\n    const update = result[1]\n    result[1] = useCallbackOne(propsArg => {\n      const reverse = is.obj(propsArg) && propsArg.reverse\n      return update((i, ctrl) => {\n        const props = getProps(propsArg, i, ctrl)!\n        const parent = ctrls[i + (reverse ? 1 : -1)]\n        if (parent) props.to = parent.springs\n        return props\n      })\n    }, deps)\n    return result\n  }\n  return result[0]\n}\n","// TODO: convert to \"const enum\" once Babel supports it\nexport type TransitionPhase =\n  | typeof MOUNT\n  | typeof ENTER\n  | typeof UPDATE\n  | typeof LEAVE\n\n/** This transition is being mounted */\nexport const MOUNT = 'mount'\n\n/** This transition is entering or has entered */\nexport const ENTER = 'enter'\n\n/** This transition had its animations updated */\nexport const UPDATE = 'update'\n\n/** This transition will expire after animating */\nexport const LEAVE = 'leave'\n","import * as React from 'react'\nimport { useRef, useMemo, useImperativeHandle } from 'react'\nimport { useLayoutEffect } from 'react-layout-effect'\nimport {\n  is,\n  toArray,\n  useForceUpdate,\n  useOnce,\n  each,\n  OneOrMore,\n  UnknownProps,\n} from '@react-spring/shared'\n\nimport {\n  Change,\n  ControllerUpdate,\n  ItemKeys,\n  PickAnimated,\n  SpringStartFn,\n  SpringStopFn,\n  TransitionFn,\n  TransitionState,\n  TransitionTo,\n  UseTransitionProps,\n  TransitionDefaultProps,\n} from '../types'\nimport { Valid } from '../types/common'\nimport { callProp, inferTo, getDefaultProps } from '../helpers'\nimport { Controller, getSprings, setSprings } from '../Controller'\nimport { useSpringContext } from '../SpringContext'\nimport { SpringHandle } from '../SpringHandle'\nimport {\n  ENTER,\n  MOUNT,\n  LEAVE,\n  UPDATE,\n  TransitionPhase,\n} from '../TransitionPhase'\n\ndeclare function setTimeout(handler: Function, timeout?: number): number\ndeclare function clearTimeout(timeoutId: number): void\n\nexport function useTransition<Item, Props extends object>(\n  data: OneOrMore<Item>,\n  props:\n    | UseTransitionProps<Item>\n    | (Props & Valid<Props, UseTransitionProps<Item>>)\n): TransitionFn<Item, PickAnimated<Props>>\n\nexport function useTransition<Item, Props extends object>(\n  data: OneOrMore<Item>,\n  props:\n    | UseTransitionProps<Item>\n    | (Props & Valid<Props, UseTransitionProps<Item>>),\n  deps: any[] | undefined\n): PickAnimated<Props> extends infer State\n  ? [\n      TransitionFn<Item, State & object>,\n      SpringStartFn<State>,\n      SpringStopFn<State>\n    ]\n  : never\n\nexport function useTransition(\n  data: unknown,\n  props: UseTransitionProps,\n  deps?: any[]\n): any {\n  const { ref, reset, sort, trail = 0, expires = true } = props\n\n  // Every item has its own transition.\n  const items = toArray(data)\n  const transitions: TransitionState[] = []\n\n  // Keys help with reusing transitions between renders.\n  // The `key` prop can be undefined (which means the items themselves are used\n  // as keys), or a function (which maps each item to its key), or an array of\n  // keys (which are assigned to each item by index).\n  const keys = getKeys(items, props)\n\n  // The \"onRest\" callbacks need a ref to the latest transitions.\n  const usedTransitions = useRef<TransitionState[] | null>(null)\n  const prevTransitions = reset ? null : usedTransitions.current\n  useLayoutEffect(() => {\n    usedTransitions.current = transitions\n  })\n\n  // Destroy all transitions on dismount.\n  useOnce(() => () =>\n    each(usedTransitions.current!, t => {\n      if (t.expired) {\n        clearTimeout(t.expirationId!)\n      }\n      t.ctrl.dispose()\n    })\n  )\n\n  // Map old indices to new indices.\n  const reused: number[] = []\n  if (prevTransitions)\n    each(prevTransitions, (t, i) => {\n      // Expired transitions are not rendered.\n      if (t.expired) {\n        clearTimeout(t.expirationId!)\n      } else {\n        i = reused[i] = keys.indexOf(t.key)\n        if (~i) transitions[i] = t\n      }\n    })\n\n  // Mount new items with fresh transitions.\n  each(items, (item, i) => {\n    transitions[i] ||\n      (transitions[i] = {\n        key: keys[i],\n        item,\n        phase: MOUNT,\n        ctrl: new Controller(),\n      })\n  })\n\n  // Update the item of any transition whose key still exists,\n  // and ensure leaving transitions are rendered until they finish.\n  if (reused.length) {\n    let i = -1\n    each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions![prevIndex]\n      if (~keyIndex) {\n        i = transitions.indexOf(t)\n        transitions[i] = { ...t, item: items[keyIndex] }\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t)\n      }\n    })\n  }\n\n  if (is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item))\n  }\n\n  // Track cumulative delay for the \"trail\" prop.\n  let delay = -trail\n\n  // Expired transitions use this to dismount.\n  const forceUpdate = useForceUpdate()\n\n  // These props are inherited by every phase change.\n  const defaultProps = getDefaultProps<TransitionDefaultProps>(props)\n\n  // Generate changes to apply in useEffect.\n  const changes = new Map<TransitionState, Change>()\n  each(transitions, (t, i) => {\n    const key = t.key\n    const prevPhase = t.phase\n\n    let to: TransitionTo<any>\n    let phase: TransitionPhase\n    if (prevPhase == MOUNT) {\n      to = props.enter\n      phase = ENTER\n    } else {\n      const isLeave = keys.indexOf(key) < 0\n      if (prevPhase != LEAVE) {\n        if (isLeave) {\n          to = props.leave\n          phase = LEAVE\n        } else if ((to = props.update)) {\n          phase = UPDATE\n        } else return\n      } else if (!isLeave) {\n        to = props.enter\n        phase = ENTER\n      } else return\n    }\n\n    // When \"to\" is a function, it can return (1) an array of \"useSpring\" props,\n    // (2) an async function, or (3) an object with any \"useSpring\" props.\n    to = callProp(to, t.item, i)\n    to = is.obj(to) ? inferTo(to) : { to }\n\n    if (!to.config) {\n      const config = props.config || defaultProps.config\n      to.config = callProp(config, t.item, i)\n    }\n\n    // The payload is used to update the spring props once the current render is committed.\n    const payload: ControllerUpdate<UnknownProps> = {\n      ...defaultProps,\n      delay: delay += trail,\n      // This prevents implied resets.\n      reset: false,\n      // Merge any phase-specific props.\n      ...(to as any),\n    }\n\n    if (phase == ENTER && is.und(payload.from)) {\n      // The `initial` prop is used on the first render of our parent component,\n      // as well as when `reset: true` is passed. It overrides the `from` prop\n      // when defined, and it makes `enter` instant when null.\n      const from =\n        is.und(props.initial) || prevTransitions ? props.from : props.initial\n\n      payload.from = callProp(from, t.item, i)\n    }\n\n    const { onRest }: { onRest?: any } = payload\n    payload.onRest = result => {\n      const transitions = usedTransitions.current!\n      const t = transitions.find(t => t.key === key)\n      if (!t) return\n\n      if (is.fun(onRest)) {\n        onRest(result, t)\n      }\n\n      // Reset the phase of a cancelled enter/leave transition, so it can\n      // retry the animation on the next render.\n      if (result.cancelled && t.phase != UPDATE) {\n        t.phase = prevPhase\n        return\n      }\n\n      if (t.ctrl.idle) {\n        const idle = transitions.every(t => t.ctrl.idle)\n        if (t.phase == LEAVE) {\n          const expiry = callProp(expires, t.item)\n          if (expiry !== false) {\n            const expiryMs = expiry === true ? 0 : expiry\n            t.expired = true\n\n            // Force update once the expiration delay ends.\n            if (!idle && expiryMs > 0) {\n              // The maximum timeout is 2^31-1\n              if (expiryMs <= 0x7fffffff)\n                t.expirationId = setTimeout(forceUpdate, expiryMs)\n              return\n            }\n          }\n        }\n        // Force update once idle and expired items exist.\n        if (idle && transitions.some(t => t.expired)) {\n          forceUpdate()\n        }\n      }\n    }\n\n    const springs = getSprings(t.ctrl, payload)\n    changes.set(t, { phase, springs, payload })\n  })\n\n  // The prop overrides from an ancestor.\n  const context = useSpringContext()\n\n  // Merge the context into each transition.\n  useLayoutEffect(() => {\n    each(transitions, t => {\n      t.ctrl.start({ default: context })\n    })\n  }, [context])\n\n  const api = useMemo(() => {\n    return SpringHandle.create(() => {\n      return usedTransitions.current!.map(t => t.ctrl)\n    })\n  }, [])\n\n  useImperativeHandle(ref, () => api)\n\n  useLayoutEffect(\n    () => {\n      each(changes, ({ phase, springs, payload }, t) => {\n        setSprings(t.ctrl, springs)\n        if (!context.cancel) {\n          t.phase = phase\n          if (phase == ENTER) {\n            t.ctrl.start({ default: context })\n          }\n          t.ctrl[ref ? 'update' : 'start'](payload)\n        }\n      })\n    },\n    reset ? void 0 : deps\n  )\n\n  const renderTransitions: TransitionFn = render => (\n    <>\n      {transitions.map((t, i) => {\n        const { springs } = changes.get(t) || t.ctrl\n        const elem: any = render({ ...springs }, t.item, t, i)\n        return elem && elem.type ? (\n          <elem.type\n            {...elem.props}\n            key={is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id}\n            ref={elem.ref}\n          />\n        ) : (\n          elem\n        )\n      })}\n    </>\n  )\n\n  return arguments.length == 3\n    ? [renderTransitions, api.start, api.stop]\n    : renderTransitions\n}\n\nfunction getKeys(\n  items: readonly any[],\n  { key, keys = key }: { key?: ItemKeys; keys?: ItemKeys }\n): readonly any[] {\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys)\n}\n","import { useSpring, UseSpringProps } from '../hooks/useSpring'\nimport { NoInfer, UnknownProps } from '../types/common'\nimport { SpringValues, SpringToFn, SpringChain } from '../types'\n\nexport type SpringComponentProps<\n  State extends object = UnknownProps\n> = unknown &\n  UseSpringProps<State> & {\n    children: (values: SpringValues<State>) => JSX.Element | null\n  }\n\n// Infer state from \"from\" object prop.\nexport function Spring<State extends object>(\n  props: {\n    from: State\n    to?: SpringChain<NoInfer<State>> | SpringToFn<NoInfer<State>>\n  } & Omit<SpringComponentProps<NoInfer<State>>, 'from' | 'to'>\n): JSX.Element | null\n\n// Infer state from \"to\" object prop.\nexport function Spring<State extends object>(\n  props: { to: State } & Omit<SpringComponentProps<NoInfer<State>>, 'to'>\n): JSX.Element | null\n\n/**\n * The `Spring` component passes `SpringValue` objects to your render prop.\n */\nexport function Spring({ children, ...props }: any) {\n  return children(useSpring(props))\n}\n","import { ReactNode } from 'react'\nimport { NoInfer, is, Falsy } from '@react-spring/shared'\n\nimport { Valid } from '../types/common'\nimport { PickAnimated, SpringValues } from '../types'\nimport { UseSpringProps } from '../hooks/useSpring'\nimport { useTrail } from '../hooks/useTrail'\n\nexport type TrailComponentProps<Item, Props extends object = any> = unknown &\n  UseSpringProps<Props> & {\n    items: readonly Item[]\n    children: (\n      item: NoInfer<Item>,\n      index: number\n    ) => ((values: SpringValues<PickAnimated<Props>>) => ReactNode) | Falsy\n  }\n\nexport function Trail<Item, Props extends TrailComponentProps<Item>>({\n  items,\n  children,\n  ...props\n}: Props & Valid<Props, TrailComponentProps<Item, Props>>) {\n  const trails: any[] = useTrail(items.length, props)\n  return items.map((item, index) => {\n    const result = children(item, index)\n    return is.fun(result) ? result(trails[index]) : result\n  })\n}\n","import * as React from 'react'\n\nimport { Valid } from '../types/common'\nimport { TransitionComponentProps } from '../types'\nimport { useTransition } from '../hooks'\n\nexport function Transition<\n  Item extends any,\n  Props extends TransitionComponentProps<Item>\n>({\n  items,\n  children,\n  ...props\n}:\n  | TransitionComponentProps<Item>\n  | (Props & Valid<Props, TransitionComponentProps<Item, Props>>)) {\n  return <>{useTransition(items, props)(children)}</>\n}\n","import {\n  is,\n  each,\n  isEqual,\n  toArray,\n  FluidValue,\n  createInterpolator,\n  InterpolatorArgs,\n  InterpolatorFn,\n  OneOrMore,\n  Arrify,\n} from '@react-spring/shared'\nimport * as G from '@react-spring/shared/globals'\n\nimport { FrameValue, isFrameValue } from './FrameValue'\nimport {\n  getAnimated,\n  setAnimated,\n  AnimatedValue,\n  AnimatedArray,\n  AnimatedType,\n  getPayload,\n} from '@react-spring/animated'\n\n/**\n * An `Interpolation` is a memoized value that's computed whenever one of its\n * `FluidValue` dependencies has its value changed.\n *\n * Other `FrameValue` objects can depend on this. For example, passing an\n * `Interpolation` as the `to` prop of a `useSpring` call will trigger an\n * animation toward the memoized value.\n */\nexport class Interpolation<In = any, Out = any> extends FrameValue<Out> {\n  /** Useful for debugging. */\n  key?: string\n\n  /** Equals false when in the frameloop */\n  idle = true\n\n  /** The function that maps inputs values to output */\n  readonly calc: InterpolatorFn<In, Out>\n\n  constructor(\n    /** The source of input values */\n    readonly source: OneOrMore<FluidValue>,\n    args: InterpolatorArgs<In, Out>\n  ) {\n    super()\n    this.calc = createInterpolator(...args)\n\n    const value = this._get()\n    const nodeType: AnimatedType = is.arr(value) ? AnimatedArray : AnimatedValue\n\n    // Assume the computed value never changes type.\n    setAnimated(this, nodeType.create(value))\n  }\n\n  advance(_dt?: number) {\n    const value = this._get()\n    const oldValue = this.get()\n    if (!isEqual(value, oldValue)) {\n      getAnimated(this)!.setValue(value)\n      this._onChange(value, this.idle)\n    }\n  }\n\n  protected _get() {\n    const inputs: Arrify<In> = is.arr(this.source)\n      ? this.source.map(node => node.get())\n      : (toArray(this.source.get()) as any)\n\n    return this.calc(...inputs)\n  }\n\n  protected _reset() {\n    each(getPayload(this)!, node => node.reset())\n    super._reset()\n  }\n\n  protected _start() {\n    this.idle = false\n\n    super._start()\n\n    if (G.skipAnimation) {\n      this.idle = true\n      this.advance()\n    } else {\n      G.frameLoop.start(this)\n    }\n  }\n\n  protected _attach() {\n    // Start observing our \"source\" once we have an observer.\n    let idle = true\n    let priority = 1\n    each(toArray(this.source), source => {\n      if (isFrameValue(source)) {\n        if (!source.idle) idle = false\n        priority = Math.max(priority, source.priority + 1)\n      }\n      source.addChild(this)\n    })\n    this.priority = priority\n    if (!idle) {\n      this._reset()\n      this._start()\n    }\n  }\n\n  protected _detach() {\n    // Stop observing our \"source\" once we have no observers.\n    each(toArray(this.source), source => {\n      source.removeChild(this)\n    })\n    // This removes us from the frameloop.\n    this.idle = true\n  }\n\n  /** @internal */\n  onParentChange(event: FrameValue.Event) {\n    // Ensure our start value respects our parent values, in case\n    // any of their animations were restarted with the \"reset\" prop.\n    if (event.type == 'start') {\n      this.advance()\n    }\n    // Change events are useful for (1) reacting to non-animated parents\n    // and (2) reacting to the last change in a parent animation.\n    else if (event.type == 'change') {\n      // If we're idle, we know for sure that this change is *not*\n      // caused by an animation.\n      if (this.idle) {\n        this.advance()\n      }\n      // Leave the frameloop when all parents are done animating.\n      else if (event.idle) {\n        this.idle = toArray(this.source).every(\n          (source: any) => source.idle !== false\n        )\n        if (this.idle) {\n          this.advance()\n          each(getPayload(this)!, node => {\n            node.done = true\n          })\n        }\n      }\n    }\n    // Ensure our priority is greater than all parents, which means\n    // our value won't be updated until our parents have updated.\n    else if (event.type == 'priority') {\n      this.priority = toArray(this.source).reduce(\n        (max, source: any) => Math.max(max, (source.priority || 0) + 1),\n        0\n      )\n    }\n    super.onParentChange(event)\n  }\n}\n","import {\n  Constrain,\n  OneOrMore,\n  Animatable,\n  ExtrapolateType,\n  InterpolatorConfig,\n  InterpolatorFn,\n  FluidValue,\n} from '@react-spring/shared'\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations'\nimport { Interpolation } from './Interpolation'\n\n/** Map the value of one or more dependencies */\nexport const to: Interpolator = (source: any, ...args: [any]) =>\n  new Interpolation(source, args)\n\n/** @deprecated Use the `to` export instead */\nexport const interpolate: Interpolator = (source: any, ...args: [any]) => (\n  deprecateInterpolate(), new Interpolation(source, args)\n)\n\n/** Extract the raw value types that are being interpolated */\nexport type Interpolated<T extends ReadonlyArray<any>> = {\n  [P in keyof T]: T[P] extends { get(): infer U } ? U : never\n}\n\n/**\n * This interpolates one or more `FluidValue` objects.\n * The exported `interpolate` function uses this type.\n */\nexport interface Interpolator {\n  // Single parent\n  <In, Out>(\n    parent: FluidValue<In>,\n    interpolator: InterpolatorFn<In, Out>\n  ): Interpolation<Out>\n\n  // Tuple of parents\n  <In extends ReadonlyArray<FluidValue>, Out>(\n    parents: In,\n    interpolator: (...args: Interpolated<In>) => Out\n  ): Interpolation<Out>\n\n  // Interpolation config\n  <Out>(\n    parents: OneOrMore<FluidValue>,\n    config: InterpolatorConfig<Out>\n  ): Interpolation<Animatable<Out>>\n\n  // Range shortcuts\n  <Out>(\n    parents: OneOrMore<FluidValue<number>> | FluidValue<number[]>,\n    range: readonly number[],\n    output: readonly Constrain<Out, Animatable>[],\n    extrapolate?: ExtrapolateType\n  ): Interpolation<Animatable<Out>>\n}\n","import { createStringInterpolator } from '@react-spring/shared/stringInterpolation'\nimport { Interpolation } from './Interpolation'\nimport { Globals } from '@react-spring/shared'\n\n// Sane defaults\nGlobals.assign({\n  createStringInterpolator,\n  to: (source, args) => new Interpolation(source, args),\n})\n\nexport { Globals }\n\n/** Advance all animations forward one frame */\nexport const update = () => Globals.frameLoop.advance()\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}