{"ast":null,"code":"import * as G from './globals';\n// The global `requestAnimationFrame` must be dereferenced to avoid \"Illegal invocation\" errors\nvar requestAnimationFrame = function (fn) {\n  return (void 0, G.requestAnimationFrame)(fn);\n};\n/**\n * FrameLoop executes its animations in order of lowest priority first.\n * Animations are retained until idle.\n */\nvar FrameLoop = /** @class */function () {\n  function FrameLoop(raf) {\n    if (raf === void 0) {\n      raf = requestAnimationFrame;\n    }\n    var idle = true;\n    var writing = false;\n    // The most recent framestamp\n    var lastTime = 0;\n    // The active animations for the current frame, sorted by lowest priority first\n    var animations = [];\n    // The priority of the currently advancing animation.\n    // To protect against a race condition whenever a frame is being processed,\n    // where the filtering of `animations` is corrupted with a shifting index,\n    // causing animations to potentially advance 2x faster than intended.\n    var priority = 0;\n    // Animations starting on the next frame\n    var startQueue = new Set();\n    // Flushed after all animations are updated.\n    // Used to dispatch events to an \"onFrame\" prop, for example.\n    var frameQueue = new Set();\n    // Flushed at the very end of each frame.\n    // Used to avoid layout thrashing in @react-spring/web, for example.\n    var writeQueue = new Set();\n    // Add an animation to the frameloop\n    var start = function (animation) {\n      var index = animations.indexOf(animation);\n      if (index < 0) {\n        index = animations.findIndex(function (other) {\n          return other.priority > animation.priority;\n        });\n        animations.splice(~index ? index : animations.length, 0, animation);\n      }\n    };\n    var loop = function () {\n      if (idle) return;\n      try {\n        advance();\n        raf(loop);\n      } catch (e) {\n        console.error(e);\n      }\n    };\n    // Start the frameloop\n    var kickoff = function () {\n      if (idle) {\n        idle = false;\n        // To minimize frame skips, the frameloop never stops.\n        if (lastTime == 0) {\n          lastTime = G.now();\n          raf(loop);\n        }\n      }\n    };\n    var timeoutQueue = [];\n    this.setTimeout = function (handler, ms) {\n      var time = G.now() + ms;\n      var cancel = function () {\n        var index = timeoutQueue.findIndex(function (t) {\n          return t.cancel == cancel;\n        });\n        if (index >= 0) {\n          timeoutQueue.splice(index, 1);\n        }\n      };\n      var index = findIndex(timeoutQueue, function (t) {\n        return t.time > time;\n      });\n      var timeout = {\n        time: time,\n        handler: handler,\n        cancel: cancel\n      };\n      timeoutQueue.splice(index, 0, timeout);\n      kickoff();\n      return timeout;\n    };\n    // Process the current frame.\n    var advance = this.advance = function () {\n      var time = G.now();\n      // Start animations that were added during last frame.\n      if (startQueue.size) {\n        startQueue.forEach(start);\n        startQueue.clear();\n      }\n      // Flush the timeout queue.\n      if (timeoutQueue.length) {\n        G.batchedUpdates(function () {\n          var count = findIndex(timeoutQueue, function (t) {\n            return t.time > time;\n          });\n          timeoutQueue.splice(0, count).forEach(function (t) {\n            return t.handler();\n          });\n        });\n      }\n      if (time > lastTime) {\n        // http://gafferongames.com/game-physics/fix-your-timestep/\n        var dt_1 = Math.min(64, time - lastTime);\n        lastTime = time;\n        G.batchedUpdates(function () {\n          // Animations can be added while the frameloop is updating,\n          // but they need a higher priority to be started on this frame.\n          if (animations.length) {\n            G.willAdvance(animations);\n            animations = animations.filter(function (animation) {\n              priority = animation.priority;\n              // Animations may go idle before the next frame.\n              if (!animation.idle) {\n                animation.advance(dt_1);\n              }\n              // Remove idle animations.\n              return !animation.idle;\n            });\n            priority = 0;\n          }\n          if (frameQueue.size) {\n            frameQueue.forEach(function (onFrame) {\n              return onFrame(time);\n            });\n            frameQueue.clear();\n          }\n          if (writeQueue.size) {\n            writing = true;\n            writeQueue.forEach(function (write) {\n              return write(time);\n            });\n            writeQueue.clear();\n            writing = false;\n          }\n        });\n      }\n    };\n    this.start = function (animation) {\n      if (priority > animation.priority) {\n        startQueue.add(animation);\n      } else {\n        start(animation);\n        kickoff();\n      }\n    };\n    this.onFrame = function (cb) {\n      frameQueue.add(cb);\n      kickoff();\n    };\n    this.onWrite = function (cb) {\n      if (writing) cb(lastTime);else writeQueue.add(cb);\n    };\n    // Expose internals for testing.\n    if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n      var dispose_1 = function () {\n        idle = true;\n        startQueue.clear();\n        timeoutQueue.length = 0;\n      };\n      Object.defineProperties(this, {\n        _animations: {\n          get: function () {\n            return animations;\n          }\n        },\n        _dispose: {\n          get: function () {\n            return dispose_1;\n          }\n        }\n      });\n    }\n  }\n  return FrameLoop;\n}();\nexport { FrameLoop };\n/** Like `Array.prototype.findIndex` but returns `arr.length` instead of `-1` */\nfunction findIndex(arr, test) {\n  var index = arr.findIndex(test);\n  return index < 0 ? arr.length : index;\n}","map":{"version":3,"mappings":"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","names":["G","requestAnimationFrame","fn","raf","idle","writing","lastTime","animations","priority","startQueue","Set","frameQueue","writeQueue","start","animation","index","indexOf","findIndex","splice","length","loop","advance","e","console","error","kickoff","now","timeoutQueue","setTimeout","handler","ms","time","cancel","timeout","size","forEach","clear","batchedUpdates","count","dt_1","Math","min","willAdvance","filter","add","onFrame","cb","onWrite","process","env","NODE_ENV","dispose_1","Object","defineProperties","_animations","get","_dispose","arr","test"],"sources":["/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/src/FrameLoop.ts"],"sourcesContent":["import { FrameRequestCallback } from './types'\nimport * as G from './globals'\n\ndeclare const console: any\ndeclare const process:\n  | { env: { [key: string]: string | undefined } }\n  | undefined\n\n// The global `requestAnimationFrame` must be dereferenced to avoid \"Illegal invocation\" errors\nconst requestAnimationFrame: RequestFrameFn = fn =>\n  (void 0, G.requestAnimationFrame)(fn)\n\nexport type RequestFrameFn = (cb: FrameRequestCallback) => number | void\n\nexport interface OpaqueAnimation {\n  idle: boolean\n  priority: number\n  advance(dt: number): void\n}\n\nexport interface Timeout {\n  time: number\n  handler: () => void\n  cancel: () => void\n}\n\n/**\n * FrameLoop executes its animations in order of lowest priority first.\n * Animations are retained until idle.\n */\nexport class FrameLoop {\n  /**\n   * Start a new animation, or reorder an active animation in\n   * the animations array in response to a priority change.\n   */\n  start: (animation: OpaqueAnimation) => void\n\n  /**\n   * Advance the animations to the current time.\n   */\n  advance: () => void\n\n  /**\n   * Invoke the given `handler` on the soonest frame after the given\n   * `ms` delay is completed. When the delay is `<= 0`, the handler is\n   * invoked immediately.\n   */\n  setTimeout: (handler: () => void, ms: number) => Timeout\n\n  /**\n   * Execute a function once after all animations have updated.\n   */\n  onFrame: (cb: FrameRequestCallback) => void\n\n  /**\n   * Execute a function once at the very end of the current frame.\n   *\n   * Only call this within an `onFrame` callback.\n   */\n  onWrite: (cb: FrameRequestCallback) => void\n\n  // Exposed for testing.\n  protected _animations!: OpaqueAnimation[]\n  protected _dispose!: () => void\n\n  constructor(raf = requestAnimationFrame) {\n    let idle = true\n    let writing = false\n\n    // The most recent framestamp\n    let lastTime = 0\n\n    // The active animations for the current frame, sorted by lowest priority first\n    let animations: OpaqueAnimation[] = []\n\n    // The priority of the currently advancing animation.\n    // To protect against a race condition whenever a frame is being processed,\n    // where the filtering of `animations` is corrupted with a shifting index,\n    // causing animations to potentially advance 2x faster than intended.\n    let priority = 0\n\n    // Animations starting on the next frame\n    const startQueue = new Set<OpaqueAnimation>()\n\n    // Flushed after all animations are updated.\n    // Used to dispatch events to an \"onFrame\" prop, for example.\n    const frameQueue = new Set<FrameRequestCallback>()\n\n    // Flushed at the very end of each frame.\n    // Used to avoid layout thrashing in @react-spring/web, for example.\n    const writeQueue = new Set<FrameRequestCallback>()\n\n    // Add an animation to the frameloop\n    const start = (animation: OpaqueAnimation) => {\n      let index = animations.indexOf(animation)\n      if (index < 0) {\n        index = animations.findIndex(\n          other => other.priority > animation.priority\n        )\n        animations.splice(~index ? index : animations.length, 0, animation)\n      }\n    }\n\n    const loop = () => {\n      if (idle) return\n      try {\n        advance()\n        raf(loop)\n      } catch (e) {\n        console.error(e)\n      }\n    }\n\n    // Start the frameloop\n    const kickoff = () => {\n      if (idle) {\n        idle = false\n\n        // To minimize frame skips, the frameloop never stops.\n        if (lastTime == 0) {\n          lastTime = G.now()\n          raf(loop)\n        }\n      }\n    }\n\n    const timeoutQueue: Timeout[] = []\n\n    this.setTimeout = (handler, ms) => {\n      const time = G.now() + ms\n      const cancel = () => {\n        const index = timeoutQueue.findIndex(t => t.cancel == cancel)\n        if (index >= 0) {\n          timeoutQueue.splice(index, 1)\n        }\n      }\n\n      const index = findIndex(timeoutQueue, t => t.time > time)\n      const timeout = { time, handler, cancel }\n      timeoutQueue.splice(index, 0, timeout)\n\n      kickoff()\n      return timeout\n    }\n\n    // Process the current frame.\n    const advance = (this.advance = () => {\n      const time = G.now()\n\n      // Start animations that were added during last frame.\n      if (startQueue.size) {\n        startQueue.forEach(start)\n        startQueue.clear()\n      }\n\n      // Flush the timeout queue.\n      if (timeoutQueue.length) {\n        G.batchedUpdates(() => {\n          const count = findIndex(timeoutQueue, t => t.time > time)\n          timeoutQueue.splice(0, count).forEach(t => t.handler())\n        })\n      }\n\n      if (time > lastTime) {\n        // http://gafferongames.com/game-physics/fix-your-timestep/\n        const dt = Math.min(64, time - lastTime)\n        lastTime = time\n\n        G.batchedUpdates(() => {\n          // Animations can be added while the frameloop is updating,\n          // but they need a higher priority to be started on this frame.\n          if (animations.length) {\n            G.willAdvance(animations)\n            animations = animations.filter(animation => {\n              priority = animation.priority\n\n              // Animations may go idle before the next frame.\n              if (!animation.idle) {\n                animation.advance(dt)\n              }\n\n              // Remove idle animations.\n              return !animation.idle\n            })\n            priority = 0\n          }\n\n          if (frameQueue.size) {\n            frameQueue.forEach(onFrame => onFrame(time))\n            frameQueue.clear()\n          }\n\n          if (writeQueue.size) {\n            writing = true\n            writeQueue.forEach(write => write(time))\n            writeQueue.clear()\n            writing = false\n          }\n        })\n      }\n    })\n\n    this.start = animation => {\n      if (priority > animation.priority) {\n        startQueue.add(animation)\n      } else {\n        start(animation)\n        kickoff()\n      }\n    }\n\n    this.onFrame = cb => {\n      frameQueue.add(cb)\n      kickoff()\n    }\n\n    this.onWrite = cb => {\n      if (writing) cb(lastTime)\n      else writeQueue.add(cb)\n    }\n\n    // Expose internals for testing.\n    if (\n      typeof process !== 'undefined' &&\n      process.env.NODE_ENV !== 'production'\n    ) {\n      const dispose = () => {\n        idle = true\n        startQueue.clear()\n        timeoutQueue.length = 0\n      }\n      Object.defineProperties(this, {\n        _animations: { get: () => animations },\n        _dispose: { get: () => dispose },\n      })\n    }\n  }\n}\n\n/** Like `Array.prototype.findIndex` but returns `arr.length` instead of `-1` */\nfunction findIndex<T>(arr: T[], test: (value: T) => boolean) {\n  const index = arr.findIndex(test)\n  return index < 0 ? arr.length : index\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}