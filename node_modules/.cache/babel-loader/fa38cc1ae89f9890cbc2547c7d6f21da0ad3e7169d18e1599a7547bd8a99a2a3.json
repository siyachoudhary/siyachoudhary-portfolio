{"ast":null,"code":"var $config = Symbol.for('FluidValue:config');\nexport { hasFluidValue, getFluidValue, getFluidConfig, setFluidConfig, addFluidObserver };\n/** Does the given value have a `FluidConfig` object? */\nvar hasFluidValue = function (arg) {\n  return !!getFluidConfig(arg);\n};\nfunction getFluidValue(arg) {\n  var config = getFluidConfig(arg);\n  return config ? config.get() : arg;\n}\nfunction getFluidConfig(arg) {\n  if (arg) return arg[$config];\n}\n/** Set the methods for observing the given object. */\nfunction setFluidConfig(target, config) {\n  Object.defineProperty(target, $config, {\n    value: config,\n    configurable: true\n  });\n}\nfunction addFluidObserver(target, observer) {\n  var config = getFluidConfig(target);\n  if (config) {\n    config.addChild(observer);\n    return function () {\n      return config.removeChild(observer);\n    };\n  }\n}\n/**\n * This class stores a single dynamic value, which can be observed by multiple `FluidObserver` objects.\n *\n * In order to support non-writable streams, this class doesn't expect a `set` method to exist.\n *\n * It can send *any* event to observers, not only change events.\n */\nvar FluidValue = /** @class */function () {\n  function FluidValue() {\n    setFluidConfig(this, this);\n  }\n  return FluidValue;\n}();\nexport { FluidValue };","map":{"version":3,"mappings":"AAAA,IAAMA,OAAO,GAAGC,MAAM,CAACC,GAAG,CAAC,mBAAmB,CAAC;AAE/C,SACEC,aAAa,EACbC,aAAa,EACbC,cAAc,EACdC,cAAc,EACdC,gBAAgB;AAGlB;AACA,IAAMJ,aAAa,GAAG,UAACK,GAAQ;EAAwB,QAAC,CAACH,cAAc,CAACG,GAAG,CAAC;AAArB,CAAqB;AAM5E,SAASJ,aAAa,CAACI,GAAQ;EAC7B,IAAMC,MAAM,GAAGJ,cAAc,CAACG,GAAG,CAAC;EAClC,OAAOC,MAAM,GAAGA,MAAM,CAACC,GAAG,EAAE,GAAGF,GAAG;AACpC;AAQA,SAASH,cAAc,CAACG,GAAQ;EAC9B,IAAIA,GAAG,EAAE,OAAOA,GAAG,CAACR,OAAO,CAAC;AAC9B;AAEA;AACA,SAASM,cAAc,CAACK,MAAc,EAAEF,MAAmB;EACzDG,MAAM,CAACC,cAAc,CAACF,MAAM,EAAEX,OAAO,EAAE;IACrCc,KAAK,EAAEL,MAAM;IACbM,YAAY,EAAE;GACf,CAAC;AACJ;AAaA,SAASR,gBAAgB,CAACI,MAAc,EAAEK,QAAuB;EAC/D,IAAMP,MAAM,GAAGJ,cAAc,CAACM,MAAM,CAAC;EACrC,IAAIF,MAAM,EAAE;IACVA,MAAM,CAACQ,QAAQ,CAACD,QAAQ,CAAC;IACzB,OAAO;MAAM,aAAO,CAACE,WAAW,CAACF,QAAQ,CAAC;IAA7B,CAA6B;;AAE9C;AAyBA;;;;;;;AAOA;EAEE;IACEV,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC;EAC5B;EAIF,iBAAC;AAAD,CAAC,EARD","names":["$config","Symbol","for","hasFluidValue","getFluidValue","getFluidConfig","setFluidConfig","addFluidObserver","arg","config","get","target","Object","defineProperty","value","configurable","observer","addChild","removeChild"],"sources":["/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/fluids/src/index.ts"],"sourcesContent":["const $config = Symbol.for('FluidValue:config')\n\nexport {\n  hasFluidValue,\n  getFluidValue,\n  getFluidConfig,\n  setFluidConfig,\n  addFluidObserver,\n}\n\n/** Does the given value have a `FluidConfig` object? */\nconst hasFluidValue = (arg: any): arg is FluidValue => !!getFluidConfig(arg)\n\n/** Get the current value of a fluid object. Returns the first argument when it's not a fluid object. */\nfunction getFluidValue<T, U = never>(\n  target: T | FluidValue<U>\n): Exclude<T, FluidValue> | U\nfunction getFluidValue(arg: any) {\n  const config = getFluidConfig(arg)\n  return config ? config.get() : arg\n}\n\ntype GetFluidConfig<T> = T extends FluidValue<infer U, infer E>\n  ? FluidConfig<U, E>\n  : FluidConfig | undefined\n\n/** Get the methods for observing the given object. Returns undefined if not a fluid object. */\nfunction getFluidConfig<T>(arg: T): GetFluidConfig<T>\nfunction getFluidConfig(arg: any) {\n  if (arg) return arg[$config]\n}\n\n/** Set the methods for observing the given object. */\nfunction setFluidConfig(target: object, config: FluidConfig) {\n  Object.defineProperty(target, $config, {\n    value: config,\n    configurable: true,\n  })\n}\n\n/** Add an observer to a fluid object. Returns an unsubscribe function if the target is a fluid object, otherwise undefined. */\nfunction addFluidObserver<E extends FluidEvent>(\n  target: FluidValue<any, E>,\n  observer: FluidObserver<E>\n): () => void\n\nfunction addFluidObserver(\n  target: object,\n  observer: FluidObserver\n): (() => void) | undefined\n\nfunction addFluidObserver(target: object, observer: FluidObserver) {\n  const config = getFluidConfig(target)\n  if (config) {\n    config.addChild(observer)\n    return () => config!.removeChild(observer)\n  }\n}\n\nexport interface ChangeEvent<T = any> {\n  type: 'change'\n  parent: FluidValue<T>\n  value: T\n}\n\n/**\n * An event sent to `FluidObserver` objects.\n */\nexport interface FluidEvent<T = any> {\n  type: string\n  parent: FluidValue<T>\n}\n\n/**\n * Compatibility layer for external data sources.\n */\nexport interface FluidConfig<T = any, Event extends FluidEvent<T> = any> {\n  get(): T\n  addChild(child: FluidObserver<Event>): void\n  removeChild(child: FluidObserver<Event>): void\n}\n\n/**\n * This class stores a single dynamic value, which can be observed by multiple `FluidObserver` objects.\n *\n * In order to support non-writable streams, this class doesn't expect a `set` method to exist.\n *\n * It can send *any* event to observers, not only change events.\n */\nexport abstract class FluidValue<T = any, Event extends FluidEvent<T> = any>\n  implements FluidConfig<T, Event> {\n  constructor() {\n    setFluidConfig(this, this)\n  }\n  abstract get(): T\n  abstract addChild(child: FluidObserver<Event>): void\n  abstract removeChild(child: FluidObserver<Event>): void\n}\n\n/**\n * This object can observe any `FluidValue` object that sends compatible events.\n */\nexport interface FluidObserver<Event extends FluidEvent = any> {\n  onParentChange(event: ChangeEvent | Event): void\n}\n\n/**\n * Add the `FluidValue` type to every property.\n */\nexport type FluidProps<T> = T extends object\n  ? { [P in keyof T]: T[P] | FluidValue<Exclude<T[P], void>> }\n  : unknown\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}