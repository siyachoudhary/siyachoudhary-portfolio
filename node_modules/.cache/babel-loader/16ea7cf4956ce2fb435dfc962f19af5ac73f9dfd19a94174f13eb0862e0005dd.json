{"ast":null,"code":"import { defineHidden, is, createInterpolator, each, getFluidConfig, isAnimatedString, useForceUpdate } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { frameLoop } from '@react-spring/shared/globals';\nimport { forwardRef, useRef, createElement } from 'react';\nimport { useLayoutEffect } from 'react-layout-effect';\nconst $node = Symbol.for('Animated:node');\nconst isAnimated = value => !!value && value[$node] === value;\n/** Get the owner's `Animated` node. */\n\nconst getAnimated = owner => owner && owner[$node];\n/** Set the owner's `Animated` node. */\n\nconst setAnimated = (owner, node) => defineHidden(owner, $node, node);\n/** Get every `AnimatedValue` in the owner's `Animated` node. */\n\nconst getPayload = owner => owner && owner[$node] && owner[$node].getPayload();\nclass Animated {\n  /** The cache of animated values */\n  constructor() {\n    this.payload = void 0;\n    // This makes \"isAnimated\" return true.\n    setAnimated(this, this);\n  }\n  /** Get the current value. Pass `true` for only animated values. */\n\n  /** Get every `AnimatedValue` used by this node. */\n  getPayload() {\n    return this.payload || [];\n  }\n}\n\n/** An animated number or a native attribute value */\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this._value = _value;\n    this.done = true;\n    this.elapsedTime = void 0;\n    this.lastPosition = void 0;\n    this.lastVelocity = void 0;\n    this.v0 = void 0;\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n  static create(from, _to) {\n    return new AnimatedValue(from);\n  }\n  getPayload() {\n    return [this];\n  }\n  getValue() {\n    return this._value;\n  }\n  /**\n   * Set the current value and optionally round it.\n   *\n   * The `step` argument does nothing whenever it equals `undefined` or `0`.\n   * It works with fractions and whole numbers. The best use case is (probably)\n   * rounding to the pixel grid with a step of:\n   *\n   *      1 / window.devicePixelRatio\n   */\n\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n      if (step) {\n        value = Math.round(value / step) * step;\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n    if (this._value === value) {\n      return false;\n    }\n    this._value = value;\n    return true;\n  }\n  reset() {\n    const {\n      done\n    } = this;\n    this.done = false;\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.lastPosition = this._value;\n      if (done) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n}\nclass AnimatedString extends AnimatedValue {\n  constructor(from, to) {\n    super(0);\n    this._value = void 0;\n    this._string = null;\n    this._toString = void 0;\n    this._toString = createInterpolator({\n      output: [from, to]\n    });\n  }\n  static create(from) {\n    let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n    if (is.str(from) && is.str(to)) {\n      return new AnimatedString(from, to);\n    }\n    throw TypeError('Expected \"from\" and \"to\" to be strings');\n  }\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n  setValue(value) {\n    if (!is.num(value)) {\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n    return true;\n  }\n  reset(goal) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n    this._value = 0;\n    super.reset();\n  }\n}\nconst TreeContext = {\n  current: null\n};\n\n/** An object containing `Animated` nodes */\nclass AnimatedObject extends Animated {\n  constructor() {\n    let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super();\n    this.source = void 0;\n    this.setValue(source);\n  }\n  getValue(animated) {\n    if (!this.source) return null;\n    const values = {};\n    each(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else {\n        const config = getFluidConfig(source);\n        if (config) {\n          values[key] = config.get();\n        } else if (!animated) {\n          values[key] = source;\n        }\n      }\n    });\n    return values;\n  }\n  /** Replace the raw object data */\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset());\n    }\n  }\n  /** Create a payload set. */\n\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      each(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n  /** Add to a payload set. */\n\n  _addToPayload(source) {\n    const config = getFluidConfig(source);\n    if (config && TreeContext.current) {\n      TreeContext.current.dependencies.add(source);\n    }\n    const payload = getPayload(source);\n    if (payload) {\n      each(payload, node => this.add(node));\n    }\n  }\n}\n\n/** An array of animated nodes */\nclass AnimatedArray extends AnimatedObject {\n  constructor(from, to) {\n    super(null);\n    this.source = void 0;\n    super.setValue(this._makeAnimated(from, to));\n  }\n  static create(from, to) {\n    return new AnimatedArray(from, to);\n  }\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n  setValue(newValue) {\n    const payload = this.getPayload(); // Reuse the payload when lengths are equal.\n\n    if (newValue && newValue.length == payload.length) {\n      each(payload, (node, i) => node.setValue(newValue[i]));\n    } else {\n      // Remake the payload when length changes.\n      this.source = this._makeAnimated(newValue);\n      this.payload = this._makePayload(this.source);\n    }\n  }\n  /** Convert the `from` and `to` values to an array of `Animated` nodes */\n\n  _makeAnimated(from) {\n    let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n    return from ? from.map((from, i) => (isAnimatedString(from) ? AnimatedString : AnimatedValue).create(from, to[i])) : [];\n  }\n}\nclass AnimatedProps extends AnimatedObject {\n  /** Equals true when an update is scheduled for \"end of frame\" */\n  constructor(update) {\n    super(null);\n    this.update = update;\n    this.dirty = false;\n  }\n  setValue(props, context) {\n    if (!props) return; // The constructor passes null.\n\n    if (context) {\n      TreeContext.current = context;\n      if (props.style) {\n        const {\n          createAnimatedStyle\n        } = context.host;\n        props = _extends(_extends({}, props), {}, {\n          style: createAnimatedStyle(props.style)\n        });\n      }\n    }\n    super.setValue(props);\n    TreeContext.current = null;\n  }\n  /** @internal */\n\n  onParentChange(_ref) {\n    let {\n      type\n    } = _ref;\n    if (!this.dirty && type === 'change') {\n      this.dirty = true;\n      frameLoop.onFrame(() => {\n        this.dirty = false;\n        this.update();\n      });\n    }\n  }\n}\nconst withAnimated = (Component, host) => forwardRef((rawProps, ref) => {\n  const instanceRef = useRef(null);\n  const hasInstance =\n  // Function components must use \"forwardRef\" to avoid being\n  // re-rendered on every animation frame.\n  !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  const forceUpdate = useForceUpdate();\n  const props = new AnimatedProps(() => {\n    const instance = instanceRef.current;\n    if (hasInstance && !instance) {\n      return; // The wrapped component forgot to forward its ref.\n    }\n\n    const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false; // Re-render the component when native updates fail.\n\n    if (didUpdate === false) {\n      forceUpdate();\n    }\n  });\n  const dependencies = new Set();\n  props.setValue(rawProps, {\n    dependencies,\n    host\n  });\n  useLayoutEffect(() => {\n    each(dependencies, dep => dep.addChild(props));\n    return () => each(dependencies, dep => dep.removeChild(props));\n  });\n  return /*#__PURE__*/createElement(Component, _extends({}, host.getComponentProps(props.getValue()), {\n    ref: hasInstance && (value => {\n      instanceRef.current = updateRef(ref, value);\n    })\n  }));\n});\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n  return value;\n}\n\n// For storing the animated version on the original component\nconst cacheKey = Symbol.for('AnimatedComponent');\nconst createHost = function (components) {\n  let {\n    applyAnimatedValues = () => false,\n    createAnimatedStyle = style => new AnimatedObject(style),\n    getComponentProps = props => props\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const hostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps\n  };\n  const animated = Component => {\n    const displayName = getDisplayName(Component) || 'Anonymous';\n    if (is.str(Component)) {\n      Component = withAnimated(Component, hostConfig);\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n    Component.displayName = \"Animated(\" + displayName + \")\";\n    return Component;\n  };\n  each(components, (Component, key) => {\n    if (!is.str(key)) {\n      key = getDisplayName(Component);\n    }\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\nconst getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedProps, AnimatedString, AnimatedValue, createHost, getAnimated, getPayload, isAnimated, setAnimated };","map":{"version":3,"mappings":"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","names":["$node","Symbol","for","isAnimated","value","getAnimated","owner","setAnimated","node","defineHidden","getPayload","Animated","constructor","payload","AnimatedValue","_value","done","elapsedTime","lastPosition","lastVelocity","v0","is","num","create","from","_to","getValue","setValue","step","Math","round","reset","AnimatedString","to","_string","_toString","createInterpolator","output","str","TypeError","goal","TreeContext","current","AnimatedObject","source","animated","values","each","key","config","getFluidConfig","get","_makePayload","Set","_addToPayload","Array","dependencies","add","AnimatedArray","_makeAnimated","map","newValue","length","i","isAnimatedString","AnimatedProps","update","dirty","props","context","style","createAnimatedStyle","host","onParentChange","type","G","onFrame","withAnimated","Component","forwardRef","rawProps","ref","instanceRef","useRef","hasInstance","fun","prototype","isReactComponent","forceUpdate","useForceUpdate","instance","didUpdate","applyAnimatedValues","useLayoutEffect","dep","addChild","removeChild","React.createElement","getComponentProps","updateRef","cacheKey","createHost","components","hostConfig","displayName","getDisplayName","arg","name"],"sources":["/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/animated/src/Animated.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/animated/src/AnimatedValue.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/animated/src/AnimatedString.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/animated/src/context.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/animated/src/AnimatedObject.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/animated/src/AnimatedArray.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/animated/src/AnimatedProps.ts","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/animated/src/withAnimated.tsx","/Users/siya/Library/Mobile Documents/com~apple~CloudDocs/MobileApps/REACT/portfolio_page/node_modules/@react-spring/animated/src/createHost.ts"],"sourcesContent":["import { defineHidden } from '@react-spring/shared'\nimport { AnimatedValue } from './AnimatedValue'\n\nconst $node: any = Symbol.for('Animated:node')\n\nexport const isAnimated = <T = any>(value: any): value is Animated<T> =>\n  !!value && value[$node] === value\n\n/** Get the owner's `Animated` node. */\nexport const getAnimated = <T = any>(owner: any): Animated<T> | undefined =>\n  owner && owner[$node]\n\n/** Set the owner's `Animated` node. */\nexport const setAnimated = (owner: any, node: Animated) =>\n  defineHidden(owner, $node, node)\n\n/** Get every `AnimatedValue` in the owner's `Animated` node. */\nexport const getPayload = (owner: any): AnimatedValue[] | undefined =>\n  owner && owner[$node] && owner[$node].getPayload()\n\nexport abstract class Animated<T = any> {\n  /** The cache of animated values */\n  protected payload?: Payload\n\n  constructor() {\n    // This makes \"isAnimated\" return true.\n    setAnimated(this, this)\n  }\n\n  /** Get the current value. Pass `true` for only animated values. */\n  abstract getValue(animated?: boolean): T\n\n  /** Set the current value. */\n  abstract setValue(value: T): void\n\n  /** Reset any animation state. */\n  abstract reset(goal?: T): void\n\n  /** Get every `AnimatedValue` used by this node. */\n  getPayload(): Payload {\n    return this.payload || []\n  }\n}\n\nexport type Payload = readonly AnimatedValue[]\n","import { is } from '@react-spring/shared'\nimport { Animated, Payload } from './Animated'\n\n/** An animated number or a native attribute value */\nexport class AnimatedValue<T = any> extends Animated {\n  done = true\n  elapsedTime!: number\n  lastPosition!: number\n  lastVelocity?: number | null\n  v0?: number | null\n\n  constructor(protected _value: T) {\n    super()\n    if (is.num(this._value)) {\n      this.lastPosition = this._value\n    }\n  }\n\n  static create<T>(from: T, _to?: T | null) {\n    return new AnimatedValue(from)\n  }\n\n  getPayload(): Payload {\n    return [this]\n  }\n\n  getValue() {\n    return this._value\n  }\n\n  /**\n   * Set the current value and optionally round it.\n   *\n   * The `step` argument does nothing whenever it equals `undefined` or `0`.\n   * It works with fractions and whole numbers. The best use case is (probably)\n   * rounding to the pixel grid with a step of:\n   *\n   *      1 / window.devicePixelRatio\n   */\n  setValue(value: T, step?: number) {\n    if (is.num(value)) {\n      this.lastPosition = value\n      if (step) {\n        value = (Math.round(value / step) * step) as any\n        if (this.done) {\n          this.lastPosition = value as any\n        }\n      }\n    }\n    if (this._value === value) {\n      return false\n    }\n    this._value = value\n    return true\n  }\n\n  reset() {\n    const { done } = this\n    this.done = false\n    if (is.num(this._value)) {\n      this.elapsedTime = 0\n      this.lastPosition = this._value\n      if (done) this.lastVelocity = null\n      this.v0 = null\n    }\n  }\n}\n","import { AnimatedValue } from './AnimatedValue'\nimport { is, createInterpolator } from '@react-spring/shared'\n\ntype Value = string | number\n\nexport class AnimatedString extends AnimatedValue<Value> {\n  protected _value!: number\n  protected _string: string | null = null\n  protected _toString: (input: number) => string\n\n  constructor(from: string, to: string) {\n    super(0)\n    this._toString = createInterpolator({ output: [from, to] })\n  }\n\n  static create<T>(from: T, to: T | null = from): AnimatedValue<T> {\n    if (is.str(from) && is.str(to)) {\n      return new AnimatedString(from, to) as any\n    }\n    throw TypeError('Expected \"from\" and \"to\" to be strings')\n  }\n\n  getValue() {\n    let value = this._string\n    return value == null ? (this._string = this._toString(this._value)) : value\n  }\n\n  setValue(value: Value) {\n    if (!is.num(value)) {\n      this._string = value\n      this._value = 1\n    } else if (super.setValue(value)) {\n      this._string = null\n    } else {\n      return false\n    }\n    return true\n  }\n\n  reset(goal?: string) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal],\n      })\n    }\n    this._value = 0\n    super.reset()\n  }\n}\n","import { FluidValue } from '@react-spring/shared'\nimport { HostConfig } from './createHost'\n\nexport type TreeContext = {\n  dependencies: Set<FluidValue>\n  host: HostConfig\n}\n\nexport const TreeContext: { current: TreeContext | null } = { current: null }\n","import { Lookup, each, getFluidConfig } from '@react-spring/shared'\nimport { Animated, isAnimated, getPayload } from './Animated'\nimport { AnimatedValue } from './AnimatedValue'\nimport { TreeContext } from './context'\n\ntype Source = Lookup | null\n\n/** An object containing `Animated` nodes */\nexport class AnimatedObject extends Animated {\n  protected source!: Source\n  constructor(source: Source = null) {\n    super()\n    this.setValue(source)\n  }\n\n  getValue(animated?: boolean): Source {\n    if (!this.source) return null\n    const values: Lookup = {}\n    each(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated)\n      } else {\n        const config = getFluidConfig(source)\n        if (config) {\n          values[key] = config.get()\n        } else if (!animated) {\n          values[key] = source\n        }\n      }\n    })\n    return values\n  }\n\n  /** Replace the raw object data */\n  setValue(source: Source) {\n    this.source = source\n    this.payload = this._makePayload(source)\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset())\n    }\n  }\n\n  /** Create a payload set. */\n  protected _makePayload(source: Source) {\n    if (source) {\n      const payload = new Set<AnimatedValue>()\n      each(source, this._addToPayload, payload)\n      return Array.from(payload)\n    }\n  }\n\n  /** Add to a payload set. */\n  protected _addToPayload(this: Set<AnimatedValue>, source: any) {\n    const config = getFluidConfig(source)\n    if (config && TreeContext.current) {\n      TreeContext.current.dependencies.add(source)\n    }\n    const payload = getPayload(source)\n    if (payload) {\n      each(payload, node => this.add(node))\n    }\n  }\n}\n","import { isAnimatedString, each } from '@react-spring/shared'\nimport { AnimatedObject } from './AnimatedObject'\nimport { AnimatedString } from './AnimatedString'\nimport { AnimatedValue } from './AnimatedValue'\n\ntype Value = number | string\ntype Source = AnimatedValue<Value>[]\n\n/** An array of animated nodes */\nexport class AnimatedArray<\n  T extends ReadonlyArray<Value> = Value[]\n> extends AnimatedObject {\n  protected source!: Source\n  constructor(from: T, to?: T) {\n    super(null)\n    super.setValue(this._makeAnimated(from, to))\n  }\n\n  static create<T extends ReadonlyArray<Value>>(from: T, to?: T) {\n    return new AnimatedArray(from, to)\n  }\n\n  getValue(): T {\n    return this.source.map(node => node.getValue()) as any\n  }\n\n  setValue(newValue: T | null) {\n    const payload = this.getPayload()\n    // Reuse the payload when lengths are equal.\n    if (newValue && newValue.length == payload.length) {\n      each(payload, (node, i) => node.setValue(newValue[i]))\n    } else {\n      // Remake the payload when length changes.\n      this.source = this._makeAnimated(newValue)\n      this.payload = this._makePayload(this.source)\n    }\n  }\n\n  /** Convert the `from` and `to` values to an array of `Animated` nodes */\n  protected _makeAnimated(from: T | null, to: T = from!) {\n    return from\n      ? from.map((from, i) =>\n          (isAnimatedString(from) ? AnimatedString : AnimatedValue).create(\n            from,\n            to[i]\n          )\n        )\n      : []\n  }\n}\n","import { FluidObserver, FluidEvent } from '@react-spring/shared'\nimport * as G from '@react-spring/shared/globals'\n\nimport { AnimatedObject } from './AnimatedObject'\nimport { TreeContext } from './context'\n\ntype Props = object & { style?: any }\n\nexport class AnimatedProps extends AnimatedObject implements FluidObserver {\n  /** Equals true when an update is scheduled for \"end of frame\" */\n  dirty = false\n\n  constructor(public update: () => void) {\n    super(null)\n  }\n\n  setValue(props: Props | null, context?: TreeContext) {\n    if (!props) return // The constructor passes null.\n    if (context) {\n      TreeContext.current = context\n      if (props.style) {\n        const { createAnimatedStyle } = context.host\n        props = { ...props, style: createAnimatedStyle(props.style) }\n      }\n    }\n    super.setValue(props)\n    TreeContext.current = null\n  }\n\n  /** @internal */\n  onParentChange({ type }: FluidEvent) {\n    if (!this.dirty && type === 'change') {\n      this.dirty = true\n      G.frameLoop.onFrame(() => {\n        this.dirty = false\n        this.update()\n      })\n    }\n  }\n}\n","import * as React from 'react'\nimport { forwardRef, useRef, Ref } from 'react'\nimport { useLayoutEffect } from 'react-layout-effect'\nimport { is, each, useForceUpdate, ElementType, FluidConfig } from '@react-spring/shared'\n\nimport { AnimatedProps } from './AnimatedProps'\nimport { HostConfig } from './createHost'\n\nexport type AnimatableComponent = string | Exclude<ElementType, string>\n\nexport const withAnimated = (Component: any, host: HostConfig) =>\n  forwardRef((rawProps: any, ref: Ref<any>) => {\n    const instanceRef = useRef<any>(null)\n    const hasInstance: boolean =\n      // Function components must use \"forwardRef\" to avoid being\n      // re-rendered on every animation frame.\n      !is.fun(Component) ||\n      (Component.prototype && Component.prototype.isReactComponent)\n\n    const forceUpdate = useForceUpdate()\n    const props = new AnimatedProps(() => {\n      const instance = instanceRef.current\n      if (hasInstance && !instance) {\n        return // The wrapped component forgot to forward its ref.\n      }\n\n      const didUpdate = instance\n        ? host.applyAnimatedValues(instance, props.getValue(true)!)\n        : false\n\n      // Re-render the component when native updates fail.\n      if (didUpdate === false) {\n        forceUpdate()\n      }\n    })\n\n    const dependencies = new Set<FluidConfig>()\n    props.setValue(rawProps, { dependencies, host })\n\n    useLayoutEffect(() => {\n      each(dependencies, dep => dep.addChild(props))\n      return () => each(dependencies, dep => dep.removeChild(props))\n    })\n\n    return (\n      <Component\n        {...host.getComponentProps(props.getValue()!)}\n        ref={\n          hasInstance &&\n          ((value: any) => {\n            instanceRef.current = updateRef(ref, value)\n          })\n        }\n      />\n    )\n  })\n\nfunction updateRef<T>(ref: Ref<T>, value: T) {\n  if (ref) {\n    if (is.fun(ref)) ref(value)\n    else (ref as any).current = value\n  }\n  return value\n}\n","import { is, each, Lookup } from '@react-spring/shared'\nimport { AnimatableComponent, withAnimated } from './withAnimated'\nimport { Animated } from './Animated'\nimport { AnimatedObject } from './AnimatedObject'\n\nexport interface HostConfig {\n  /** Provide custom logic for native updates */\n  applyAnimatedValues: (node: any, props: Lookup) => boolean | void\n  /** Wrap the `style` prop with an animated node */\n  createAnimatedStyle: (style: Lookup) => Animated\n  /** Intercept props before they're passed to an animated component */\n  getComponentProps: (props: Lookup) => typeof props\n}\n\n// A stub type that gets replaced by @react-spring/web and others.\ntype WithAnimated = {\n  (Component: AnimatableComponent): any\n  [key: string]: any\n}\n\n// For storing the animated version on the original component\nconst cacheKey = Symbol.for('AnimatedComponent')\n\nexport const createHost = (\n  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },\n  {\n    applyAnimatedValues = () => false,\n    createAnimatedStyle = style => new AnimatedObject(style),\n    getComponentProps = props => props,\n  }: Partial<HostConfig> = {}\n) => {\n  const hostConfig: HostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps,\n  }\n\n  const animated: WithAnimated = (Component: any) => {\n    const displayName = getDisplayName(Component) || 'Anonymous'\n\n    if (is.str(Component)) {\n      Component = withAnimated(Component, hostConfig)\n    } else {\n      Component =\n        Component[cacheKey] ||\n        (Component[cacheKey] = withAnimated(Component, hostConfig))\n    }\n\n    Component.displayName = `Animated(${displayName})`\n    return Component\n  }\n\n  each(components, (Component, key) => {\n    if (!is.str(key)) {\n      key = getDisplayName(Component)!\n    }\n    animated[key] = animated(Component)\n  })\n\n  return {\n    animated,\n  }\n}\n\nconst getDisplayName = (arg: AnimatableComponent) =>\n  is.str(arg)\n    ? arg\n    : arg && is.str(arg.displayName)\n    ? arg.displayName\n    : (is.fun(arg) && arg.name) || null\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}